{"version":3,"sources":["node_modules/browser-pack/_prelude.js","ts-dist/AnimatedParticle.js","ts-dist/CatmullRom.js","ts-dist/Emitter.js","ts-dist/Particle.js","ts-dist/ParticleUtils.js","ts-dist/PathParticle.js","ts-dist/PropertyList.js","ts-dist/PropertyNode.js","ts-dist/particles.js","ts-dist"],"names":["f","exports","module","define","amd","g","window","global","self","this","pixiParticles","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","1","_dereq_","__extends","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","hasOwnProperty","__","constructor","prototype","create","defineProperty","value","Particle_1","Texture","PIXI","AnimatedParticle","_super","emitter","_this","textures","duration","framerate","elapsed","loop","init","Particle_init","maxLife","applyArt","art","update","delta","lerp","Particle_update","frame","texture","EMPTY","destroy","Particle_destroy","parseArt","data","output","tex","outTextures","outArr","j","push","fromImage","dupe","count","default","CatmullRom","controlPoints","kAlpha","pointsPerSegment","_controlPoints","_kAlpha","_pointsPerSegment","_points","_dirty","mergeUnique","args","_i","arguments","encode","hash","ret","x","y","pointDistance","Math","sqrt","pow","pointAngle","atan2","getNearest","point","newDist","nearest","dist","getIndex","progress","index","floor","getNormals","pointPrev","pointNext","len","dx","dy","toward","Point","away","get","populate","set","newVal","enumerable","configurable","last","catmullRomSpline","P0","P1","P2","P3","tNext","tPrev","pPrev","pNext","AN","tP","tN","PP","PN","BN","AP","t0","t1","t2","t3","segments","numKnots","A1","A2","A3","B1","B2","ParticleUtils_1","PropertyNode_1","ticker","shared","CatmullRom_1","helperPoint","Emitter","particleParent","particleImages","config","_particleConstructor","startAlpha","startSpeed","minimumSpeedMultiplier","acceleration","maxSpeed","NaN","startScale","minimumScaleMultiplier","startColor","minLifetime","maxLifetime","minStartRotation","maxStartRotation","noRotation","minRotationSpeed","maxRotationSpeed","particleBlendMode","customEase","extraData","_frequency","spawnChance","maxParticles","emitterLifetime","spawnPos","spawnType","_spawnFunc","spawnRect","spawnCircle","spawnSpline","particlesPerWave","particleSpacing","angleStart","rotation","ownerPos","_prevEmitterPos","_prevPosIsValid","_posChanged","_parent","addAtBack","particleCount","_emit","_spawnTimer","_emitterLife","_activeParticlesFirst","_activeParticlesLast","_poolFirst","_origConfig","_origArt","_autoUpdate","_destroyWhenComplete","_completeCallback","parent","recycle","rotate","updateSpawnPos","updateOwnerPos","cleanup","particle","next","isArray","slice","partClass","alpha","createList","speed","scale","color","startRotation","min","max","rotationSpeed","lifetime","getBlendMode","blendMode","ease","generateEase","parseData","_spawnRect","Rectangle","w","h","_spawnCircle","Circle","_spawnRing","minRadius","minR","_spawnBurst","_spawnSpline","_spawnPoint","frequency","pos","clone","emit","undefined","autoUpdate","prev","removeChild","newRot","diff","rotatePoint","resetPositionTracking","remove","add","playOnceAndDestroy","callback","playOnce","settings","TARGET_FPMS","prevX","prevY","curX","curY","random","emitPosX","emitPosY","particleConstructor","alphaList","reset","speedMultiplier","speedList","scaleMultiplier","scaleList","colorList","children","shift","pop","indexOf","splice","unshift","addChildAt","addChild","position","width","height","radius","angle","points","normal","RAD_TO_DEG","PropertyList_1","Sprite","Particle","anchor","velocity","age","_doAlpha","_doScale","_doSpeed","_doAcceleration","_doColor","_doNormalMovement","_oneOverLife","Sprite_destroy","kill","current","DEG_TO_RADS","tint","combineRGBComponents","visible","interpolate","normalize","scaleBy","currentSpeed","verbose","baseTexture","console","warn","BLEND_MODES","ParticleUtils","PI","s","sin","cos","xnew","ynew","oneOverLen","hexToRGB","charAt","substr","parseInt","qty","oneOverQty","time","cp","name","NORMAL","toUpperCase","replace","createSteppedGradient","list","numSteps","first","isStepped","currentNode","nextIndex","curVal","nextVal","MATH_FUNCS","WHITELISTER","RegExp","concat","join","parsePath","pathString","matches","match","Function","PathParticle","path","initialRotation","initialPosition","movement","error","intValueSimple","intColorSimple","intValueComplex","intColorComplex","intValueStepped","intColorStepped","PropertyList","isColor","PropertyNode","array","node","start","end","ParticleUtils_js_1","Particle_js_1","Emitter_js_1","PathParticle_js_1","AnimatedParticle_js_1","CatmullRom_js_1","particles","prop"],"mappings":";;;;;;;CAAA,SAAAA,GAAA,GAAA,gBAAAC,UAAA,mBAAAC,QAAAA,OAAAD,QAAAD,QAAA,IAAA,kBAAAG,SAAAA,OAAAC,IAAAD,UAAAH,OAAA,CAAA,GAAAK,EAAAA,GAAA,mBAAAC,QAAAA,OAAA,mBAAAC,QAAAA,OAAA,mBAAAC,MAAAA,KAAAC,KAAAJ,EAAAK,cAAAV,MAAA,WAAA,MAAA,YAAA,QAAAW,GAAAC,EAAAC,EAAAC,GAAA,QAAAC,GAAAC,EAAAhB,GAAA,IAAAa,EAAAG,GAAA,CAAA,IAAAJ,EAAAI,GAAA,CAAA,GAAAC,GAAA,kBAAAC,UAAAA,OAAA,KAAAlB,GAAAiB,EAAA,MAAAA,GAAAD,GAAA,EAAA,IAAAG,EAAA,MAAAA,GAAAH,GAAA,EAAA,IAAAI,GAAA,GAAAC,OAAA,uBAAAL,EAAA,IAAA,MAAAI,GAAAE,KAAA,mBAAAF,EAAA,GAAAG,GAAAV,EAAAG,IAAAf,WAAAW,GAAAI,GAAA,GAAAQ,KAAAD,EAAAtB,QAAA,SAAAU,GAAA,MAAAI,GAAAH,EAAAI,GAAA,GAAAL,IAAAA,IAAAY,EAAAA,EAAAtB,QAAAU,EAAAC,EAAAC,EAAAC,GAAA,MAAAD,GAAAG,GAAAf,QAAA,IAAA,GAAAkB,GAAA,kBAAAD,UAAAA,QAAAF,EAAA,EAAAA,EAAAF,EAAAW,OAAAT,IAAAD,EAAAD,EAAAE,GAAA,OAAAD,GAAA,MAAAJ,OAAAe,GAAA,SAAAC,EAAAzB,EAAAD,GCAA,YACA,IAAA2B,GAAAnB,MAAAA,KAAAmB,WAAA,WACA,GAAAC,GAAAC,OAAAC,iBACAC,uBAAAC,QAAA,SAAAC,EAAAC,GAAAD,EAAAF,UAAAG,IACA,SAAAD,EAAAC,GAAA,IAAA,GAAAZ,KAAAY,GAAAA,EAAAC,eAAAb,KAAAW,EAAAX,GAAAY,EAAAZ,IACA,OAAA,UAAAW,EAAAC,GAEA,QAAAE,KAAA5B,KAAA6B,YAAAJ,EADAL,EAAAK,EAAAC,GAEAD,EAAAK,UAAA,OAAAJ,EAAAL,OAAAU,OAAAL,IAAAE,EAAAE,UAAAJ,EAAAI,UAAA,GAAAF,OAGAP,QAAAW,eAAAxC,EAAA,cAAAyC,OAAA,GACA,IAAAC,GAAAhB,EAAA,cACAiB,EAAAC,KAAAD,QAoCAE,EAAA,SAAAC,GAEA,QAAAD,GAAAE,GACA,GAAAC,GAAAF,EAAAvB,KAAAf,KAAAuC,IAAAvC,IAMA,OALAwC,GAAAC,SAAA,KACAD,EAAAE,SAAA,EACAF,EAAAG,UAAA,EACAH,EAAAI,QAAA,EACAJ,EAAAK,MAAA,EACAL,EA8GA,MAtHArB,GAAAkB,EAAAC,GAeAD,EAAAP,UAAAgB,KAAA,WACA9C,KAAA+C,gBACA/C,KAAA4C,QAAA,EAEA5C,KAAA2C,UAAA,IACA3C,KAAA0C,SAAA1C,KAAAgD,QACAhD,KAAA2C,UAAA3C,KAAAyC,SAAAzB,OAAAhB,KAAA0C,WAQAL,EAAAP,UAAAmB,SAAA,SAAAC,GACAlD,KAAAyC,SAAAS,EAAAT,SACAzC,KAAA2C,UAAAO,EAAAP,UACA3C,KAAA0C,SAAAQ,EAAAR,SACA1C,KAAA6C,KAAAK,EAAAL,MAOAR,EAAAP,UAAAqB,OAAA,SAAAC,GACA,GAAAC,GAAArD,KAAAsD,gBAAAF,EAEA,IAAAC,GAAA,EAAA,CACArD,KAAA4C,SAAAQ,EACApD,KAAA4C,QAAA5C,KAAA0C,WAEA1C,KAAA6C,KACA7C,KAAA4C,QAAA5C,KAAA4C,QAAA5C,KAAA0C,SAGA1C,KAAA4C,QAAA5C,KAAA0C,SAAA,KAEA,IAAAa,GAAAvD,KAAA4C,QAAA5C,KAAA2C,UAAA,KAAA,CACA3C,MAAAwD,QAAAxD,KAAAyC,SAAAc,IAAAnB,KAAAD,QAAAsB,MAEA,MAAAJ,IAMAhB,EAAAP,UAAA4B,QAAA,WACA1D,KAAA2D,mBACA3D,KAAAyC,SAAA,MAUAJ,EAAAuB,SAAA,SAAAV,GAGA,IAAA,GAFAW,GAAAC,EAAArB,EAAAsB,EAAAC,EACAC,KACA1D,EAAA,EAAAA,EAAA2C,EAAAlC,SAAAT,EAAA,CACAsD,EAAAX,EAAA3C,GACA0D,EAAA1D,GAAAuD,KACAA,EAAArB,SAAAuB,KACAvB,EAAAoB,EAAApB,QACA,KAAA,GAAAyB,GAAA,EAAAA,EAAAzB,EAAAzB,SAAAkD,EAEA,GAAA,iBADAH,EAAAtB,EAAAyB,IAEAF,EAAAG,KAAAhC,EAAAiC,UAAAL,QACA,IAAAA,YAAA5B,GACA6B,EAAAG,KAAAJ,OAEA,CACA,GAAAM,GAAAN,EAAAO,OAAA,CAKA,KAHAP,EADA,gBAAAA,GAAAP,QACArB,EAAAiC,UAAAL,EAAAP,SAEAO,EAAAP,QACAa,EAAA,IAAAA,EACAL,EAAAG,KAAAJ,GAKA,aAAAF,EAAAlB,WAEAmB,EAAAnB,WAAA,EACAmB,EAAApB,SAAA,EACAoB,EAAAjB,MAAA,IAIAiB,EAAAjB,OAAAgB,EAAAhB,KAEAiB,EAAAnB,UAAAkB,EAAAlB,UAAA,EAAAkB,EAAAlB,UAAA,GAEAmB,EAAApB,SAAAsB,EAAAhD,OAAA8C,EAAAnB,WAGA,MAAAsB,IAEA5B,GACAH,EAAAqC,QACA/E,GAAA+E,QAAAlC,wCC1KA,YACAhB,QAAAW,eAAAxC,EAAA,cAAAyC,OAAA,GAMA,IAAAuC,GAAA,WASA,QAAAA,GAAAC,EAAAC,EAAAC,GACA3E,KAAA4E,eAAAH,EACAzE,KAAA6E,QAAA,GAAAH,EAAA,EAAAA,GAAA,GACA1E,KAAA8E,kBAAAH,GAAA,GACA3E,KAAA+E,WACA/E,KAAAgF,QAAA,EA+PA,MAzPAR,GAAAS,YAAA,WAEA,IAAA,GADAC,MACAC,EAAA,EAAAA,EAAAC,UAAApE,OAAAmE,IACAD,EAAAC,GAAAC,UAAAD,EAEA,IAAAE,GAAA9E,EAAA2D,EAAAoB,KAAAC,IACA,KAAAhF,EAAA,EAAAA,EAAA2E,EAAAlE,OAAAT,IACA,IAAA2D,EAAA,EAAAA,EAAAgB,EAAA3E,GAAAS,OAAAkD,IACAmB,EAAAH,EAAA3E,GAAA2D,GAAAsB,EAAA,IAAAN,EAAA3E,GAAA2D,GAAAuB,GACA,IAAAH,EAAAD,KACAC,EAAAD,IAAA,EACAE,EAAAA,EAAAvE,QAAAkE,EAAA3E,GAAA2D,GAIA,OAAAqB,IAMAf,EAAAkB,cAAA,SAAA/E,EAAAe,GACA,MAAAiE,MAAAC,KAAAD,KAAAE,IAAAlF,EAAA6E,EAAA9D,EAAA8D,EAAA,GAAAG,KAAAE,IAAAlF,EAAA8E,EAAA/D,EAAA+D,EAAA,KAMAjB,EAAAsB,WAAA,SAAAnF,EAAAe,GACA,MAAAiE,MAAAI,MAAArE,EAAA8D,EAAA7E,EAAA6E,EAAA9D,EAAA+D,EAAA9E,EAAA8E,IAQAjB,EAAA1C,UAAAkE,WAAA,SAAAC,GAIA,IAAA,GADAC,GAFAC,EAAA,EACAC,EAAA5B,EAAAkB,cAAAO,EAAAjG,KAAA+E,QAAA,IAEAxE,EAAA,EAAAA,EAAAP,KAAA+E,QAAA/D,OAAAT,IAAA,CACA,GAAAP,KAAA+E,QAAAxE,GAAAiF,IAAAS,EAAAT,GAAAxF,KAAA+E,QAAAxE,GAAAkF,IAAAQ,EAAAR,EACA,MAAAzF,MAAA+E,QAAAxE,EAGA2F,GAAA1B,EAAAkB,cAAAO,EAAAjG,KAAA+E,QAAAxE,IACA6F,EAAAF,IACAC,EAAA5F,EACA6F,EAAAF,GAIA,MAAAlG,MAAA+E,QAAAoB,IAQA3B,EAAA1C,UAAAuE,SAAA,SAAAC,GACA,GAAAC,GAAAvG,KAAA+E,QAAA,QAAAuB,EAAA,EAIA,OAHAC,GAAA,IACAA,EAAAvG,KAAA+E,QAAA/D,OAAAuF,GAEAZ,KAAAa,MAAAD,IAQA/B,EAAA1C,UAAA2E,WAAA,SAAAF,GACA,GAAAG,GAAA1G,KAAA+E,QAAA,IAAAwB,EAAAvG,KAAA+E,QAAA/D,OAAA,EAAAuF,EAAA,GACAI,EAAA3G,KAAA+E,QAAAwB,IAAAvG,KAAA+E,QAAA/D,OAAA,EAAA,EAAAuF,EAAA,GACAK,EAAApC,EAAAkB,cAAAgB,EAAAC,GACAE,GAAAF,EAAAnB,EAAAkB,EAAAlB,GAAAoB,EACAE,GAAAH,EAAAlB,EAAAiB,EAAAjB,GAAAmB,CACA,QAAAG,OAAA,GAAA3E,MAAA4E,OAAAF,EAAAD,GAAAI,KAAA,GAAA7E,MAAA4E,MAAAF,GAAAD,KAGAxF,OAAAW,eAAAwC,EAAA1C,UAAA,iBAIAoF,IAAA,WAIA,MAHAlH,MAAAgF,QACAhF,KAAAmH,WAEAnH,KAAA4E,gBAEAwC,IAAA,SAAAC,GACArH,KAAA4E,eAAAyC,EACArH,KAAAgF,QAAA,GAEAsC,YAAA,EACAC,cAAA,IAIAlG,OAAAW,eAAAwC,EAAA1C,UAAA,UAIAoF,IAAA,WAIA,MAHAlH,MAAAgF,QACAhF,KAAAmH,WAEAnH,KAAA6E,SAEAuC,IAAA,SAAAC,GACArH,KAAA6E,UAAAwC,IACArH,KAAA6E,QAAAwC,EACArH,KAAAgF,QAAA,IAGAsC,YAAA,EACAC,cAAA,IAIAlG,OAAAW,eAAAwC,EAAA1C,UAAA,oBAIAoF,IAAA,WAIA,MAHAlH,MAAAgF,QACAhF,KAAAmH,WAEAnH,KAAA8E,mBAEAsC,IAAA,SAAAC,GACArH,KAAA8E,oBAAAuC,IACArH,KAAA8E,kBAAAuC,EACArH,KAAAgF,QAAA,IAGAsC,YAAA,EACAC,cAAA,IAIAlG,OAAAW,eAAAwC,EAAA1C,UAAA,UAIAoF,IAAA,WAIA,MAHAlH,MAAAgF,QACAhF,KAAAmH,WAEAnH,KAAA+E,SAEAuC,YAAA,EACAC,cAAA,IAOA/C,EAAA1C,UAAAqF,SAAA,WACA,GAAAK,GAAAxH,KAAA4E,eAAA5D,OAAA,CACAhB,MAAA+E,QAAA/E,KAAAyH,iBAAAzH,KAAA4E,eAAA4C,GAAAxH,KAAA4E,eAAA,GAAA5E,KAAA4E,eAAA,GAAA5E,KAAA4E,eAAA,GACA,KAAA,GAAArE,GAAA,EAAAA,EAAAiH,EAAA,EAAAjH,IACAP,KAAA+E,QAAAP,EAAAS,YAAAjF,KAAA+E,QAAA/E,KAAAyH,iBAAAzH,KAAA4E,eAAArE,EAAA,GAAAP,KAAA4E,eAAArE,GAAAP,KAAA4E,eAAArE,EAAA,GAAAP,KAAA4E,eAAArE,EAAA,IAEAP,MAAA+E,QAAAP,EAAAS,YAAAjF,KAAA+E,QAAA/E,KAAAyH,iBAAAzH,KAAA4E,eAAA4C,EAAA,GAAAxH,KAAA4E,eAAA4C,EAAA,GAAAxH,KAAA4E,eAAA4C,GAAAxH,KAAA4E,eAAA,IAAA5E,KAAAyH,iBAAAzH,KAAA4E,eAAA4C,EAAA,GAAAxH,KAAA4E,eAAA4C,GAAAxH,KAAA4E,eAAA,GAAA5E,KAAA4E,eAAA,KACA5E,KAAAgF,QAAA,GAUAR,EAAA1C,UAAA2F,iBAAA,SAAAC,EAAAC,EAAAC,EAAAC,GAGA,QAAAC,GAAAC,EAAAC,EAAAC,EAAAvD,GACA,MAAAiB,MAAAE,IAAAF,KAAAC,KAAAD,KAAAE,IAAAoC,EAAAzC,EAAAwC,EAAAxC,EAAA,GAAAG,KAAAE,IAAAoC,EAAAxC,EAAAuC,EAAAvC,EAAA,IAAAf,GAAAqD,EAyBA,QAAAG,GAAA7H,EAAA8H,EAAAC,EAAAC,EAAAC,GACA,GAAA9C,IAAA4C,EAAA/H,IAAA+H,EAAAD,GAAAE,EAAA7C,GAAAnF,EAAA8H,IAAAC,EAAAD,GAAAG,EAAA9C,EACAC,GAAA2C,EAAA/H,IAAA+H,EAAAD,GAAAE,EAAA5C,GAAApF,EAAA8H,IAAAC,EAAAD,GAAAG,EAAA7C,CACA,OAAA,IAAArD,MAAA4E,MAAAxB,EAAAC,GAWA,QAAA8C,GAAAlI,EAAA8H,EAAAC,EAAAI,EAAAN,GACA,GAAA1C,IAAA4C,EAAA/H,IAAA+H,EAAAD,GAAAK,EAAAhD,GAAAnF,EAAA8H,IAAAC,EAAAD,GAAAD,EAAA1C,EACAC,GAAA2C,EAAA/H,IAAA+H,EAAAD,GAAAK,EAAA/C,GAAApF,EAAA8H,IAAAC,EAAAD,GAAAD,EAAAzC,CACA,OAAA,IAAArD,MAAA4E,MAAAxB,EAAAC,GA5CA,GAAAgD,GAAAC,EAAAC,EAAAC,CAIAH,GAAA,EACAC,EAAAZ,EAAAW,EAAAf,EAAAC,EAAA3H,KAAA6E,SACA8D,EAAAb,EAAAY,EAAAf,EAAAC,EAAA5H,KAAA6E,SACA+D,EAAAd,EAAAa,EAAAf,EAAAC,EAAA7H,KAAA6E,QAwDA,KAAA,GAFAgE,GApDA,SAAAH,EAAAC,EAAAG,GAGA,IAFA,GAAAvD,IAAAmD,GACAtC,GAAAuC,EAAAD,IAAAI,EAAA,GACAvD,EAAAvE,OAAA8H,EAAA,GACAvD,EAAAA,EAAAvE,QAAAuE,EAAAA,EAAAvE,OAAA,GAAAoF,CAGA,OADAb,GAAAA,EAAAvE,QAAA2H,EACApD,GA6CAmD,EAAAC,EAAA3I,KAAA8E,mBACAS,KACAhF,EAAA,EAAAA,EAAAsI,EAAA7H,OAAAT,IACAgF,EAAAhF,GAbA,SAAAF,GACA,GAAA0I,GAAAb,EAAA7H,EAAAoI,EAAAC,EAAAhB,EAAAC,GACAqB,EAAAd,EAAA7H,EAAAqI,EAAAC,EAAAhB,EAAAC,GACAqB,EAAAf,EAAA7H,EAAAsI,EAAAC,EAAAhB,EAAAC,GACAqB,EAAAX,EAAAlI,EAAAoI,EAAAE,EAAAI,EAAAC,GACAG,EAAAZ,EAAAlI,EAAAqI,EAAAE,EAAAI,EAAAC,GACAzD,GAAAmD,EAAAtI,IAAAsI,EAAAD,GAAAQ,EAAA1D,GAAAnF,EAAAqI,IAAAC,EAAAD,GAAAS,EAAA3D,EACAC,GAAAkD,EAAAtI,IAAAsI,EAAAD,GAAAQ,EAAAzD,GAAApF,EAAAqI,IAAAC,EAAAD,GAAAS,EAAA1D,CACA,OAAA,IAAArD,MAAA4E,MAAAxB,EAAAC,IAKAoD,EAAAtI,GAEA,OAAAgF,IAEAf,IAEAhF,GAAA+E,QAAAC,0BCtRA,YACAnD,QAAAW,eAAAxC,EAAA,cAAAyC,OAAA,GACA,IAAAmH,GAAAlI,EAAA,mBACAgB,EAAAhB,EAAA,cACAmI,EAAAnI,EAAA,kBACAoI,EAAAlH,KAAAkH,OAAAC,OACAC,EAAAtI,EAAA,gBACAuI,EAAA,GAAArH,MAAA4E,MAiBA0C,EAAA,WACA,QAAAA,GAAAC,EAAAC,EAAAC,GACA7J,KAAA8J,qBAAA5H,EAAAqC,QAEAvE,KAAA4J,eAAA,KACA5J,KAAA+J,WAAA,KACA/J,KAAAgK,WAAA,KACAhK,KAAAiK,uBAAA,EACAjK,KAAAkK,aAAA,KACAlK,KAAAmK,SAAAC,IACApK,KAAAqK,WAAA,KACArK,KAAAsK,uBAAA,EACAtK,KAAAuK,WAAA,KACAvK,KAAAwK,YAAA,EACAxK,KAAAyK,YAAA,EACAzK,KAAA0K,iBAAA,EACA1K,KAAA2K,iBAAA,EACA3K,KAAA4K,YAAA,EACA5K,KAAA6K,iBAAA,EACA7K,KAAA8K,iBAAA,EACA9K,KAAA+K,kBAAA,EACA/K,KAAAgL,WAAA,KACAhL,KAAAiL,UAAA,KAEAjL,KAAAkL,WAAA,EACAlL,KAAAmL,YAAA,EACAnL,KAAAoL,aAAA,IACApL,KAAAqL,iBAAA,EACArL,KAAAsL,SAAA,KACAtL,KAAAuL,UAAA,KACAvL,KAAAwL,WAAA,KACAxL,KAAAyL,UAAA,KACAzL,KAAA0L,YAAA,KACA1L,KAAA2L,YAAA,KACA3L,KAAA4L,iBAAA,EACA5L,KAAA6L,gBAAA,EACA7L,KAAA8L,WAAA,EAEA9L,KAAA+L,SAAA,EACA/L,KAAAgM,SAAA,KACAhM,KAAAiM,gBAAA,KACAjM,KAAAkM,iBAAA,EACAlM,KAAAmM,aAAA,EACAnM,KAAAoM,QAAA,KACApM,KAAAqM,WAAA,EACArM,KAAAsM,cAAA,EACAtM,KAAAuM,OAAA,EACAvM,KAAAwM,YAAA,EACAxM,KAAAyM,cAAA,EACAzM,KAAA0M,sBAAA,KACA1M,KAAA2M,qBAAA,KACA3M,KAAA4M,WAAA,KACA5M,KAAA6M,YAAA,KACA7M,KAAA8M,SAAA,KACA9M,KAAA+M,aAAA,EACA/M,KAAAgN,sBAAA,EACAhN,KAAAiN,kBAAA,KAEAjN,KAAAkN,OAAAvD,EACAC,GAAAC,GACA7J,KAAA8C,KAAA8G,EAAAC,GAEA7J,KAAAmN,QAAAnN,KAAAmN,QACAnN,KAAAmD,OAAAnD,KAAAmD,OACAnD,KAAAoN,OAAApN,KAAAoN,OACApN,KAAAqN,eAAArN,KAAAqN,eACArN,KAAAsN,eAAAtN,KAAAsN,eAmvBA,MAjvBAjM,QAAAW,eAAA0H,EAAA5H,UAAA,aAMAoF,IAAA,WAAA,MAAAlH,MAAAkL,YACA9D,IAAA,SAAAnF,GAGAjC,KAAAkL,WADA,gBAAAjJ,IAAAA,EAAA,EACAA,EAEA,GAEAqF,YAAA,EACAC,cAAA,IAEAlG,OAAAW,eAAA0H,EAAA5H,UAAA,uBAOAoF,IAAA,WAAA,MAAAlH,MAAA8J,sBACA1C,IAAA,SAAAnF,GACA,GAAAA,GAAAjC,KAAA8J,qBAAA,CACA9J,KAAA8J,qBAAA7H,EAEAjC,KAAAuN,SAEA,KAAA,GAAAC,GAAAxN,KAAA4M,WAAAY,EAAAA,EAAAA,EAAAC,KACAD,EAAA9J,SAEA1D,MAAA4M,WAAA,KAEA5M,KAAA6M,aAAA7M,KAAA8M,UACA9M,KAAA8C,KAAA9C,KAAA8M,SAAA9M,KAAA6M,eAGAvF,YAAA,EACAC,cAAA,IAEAlG,OAAAW,eAAA0H,EAAA5H,UAAA,UAKAoF,IAAA,WAAA,MAAAlH,MAAAoM,SACAhF,IAAA,SAAAnF,GACAjC,KAAAuN,UACAvN,KAAAoM,QAAAnK,GAEAqF,YAAA,EACAC,cAAA,IAQAmC,EAAA5H,UAAAgB,KAAA,SAAAI,EAAA2G,GACA,GAAA3G,GAAA2G,EAAA,CAGA7J,KAAAuN,UAGAvN,KAAA6M,YAAAhD,EACA7J,KAAA8M,SAAA5J,EAEAA,EAAA1B,MAAAkM,QAAAxK,GAAAA,EAAAyK,SAAAzK,EAEA,IAAA0K,GAAA5N,KAAA8J,oBACA9J,MAAA4J,eAAAgE,EAAAhK,SAAAgK,EAAAhK,SAAAV,GAAAA,EAKA2G,EAAAgE,MACA7N,KAAA+J,WAAAV,EAAA9E,QAAAuJ,WAAAjE,EAAAgE,OAGA7N,KAAA+J,WAAA,GAAAV,GAAA9E,QAAA,EAAA,GAEAsF,EAAAkE,OACA/N,KAAAgK,WAAAX,EAAA9E,QAAAuJ,WAAAjE,EAAAkE,OACA/N,KAAAiK,uBAAAJ,EAAAkE,MAAA9D,wBAAA,IAGAjK,KAAAiK,uBAAA,EACAjK,KAAAgK,WAAA,GAAAX,GAAA9E,QAAA,EAAA,GAGA,IAAA2F,GAAAL,EAAAK,YACAA,KAAAA,EAAA1E,GAAA0E,EAAAzE,IAEAzF,KAAAgK,WAAAyD,KAAA,KACAzN,KAAAkK,aAAA,GAAA9H,MAAA4E,MAAAkD,EAAA1E,EAAA0E,EAAAzE,GACAzF,KAAAmK,SAAAN,EAAAM,UAAAC,KAGApK,KAAAkK,aAAA,GAAA9H,MAAA4E,MAEA6C,EAAAmE,OACAhO,KAAAqK,WAAAhB,EAAA9E,QAAAuJ,WAAAjE,EAAAmE,OACAhO,KAAAsK,uBAAAT,EAAAmE,MAAA1D,wBAAA,IAGAtK,KAAAqK,WAAA,GAAAhB,GAAA9E,QAAA,EAAA,GACAvE,KAAAsK,uBAAA,GAGAT,EAAAoE,MACAjO,KAAAuK,WAAAlB,EAAA9E,QAAAuJ,WAAAjE,EAAAoE,OAGAjO,KAAAuK,WAAA,GAAAlB,GAAA9E,SAAArE,EAAA,IAAAN,EAAA,IAAA8B,EAAA,KAAA,GAGAmI,EAAAqE,eACAlO,KAAA0K,iBAAAb,EAAAqE,cAAAC,IACAnO,KAAA2K,iBAAAd,EAAAqE,cAAAE,KAGApO,KAAA0K,iBAAA1K,KAAA2K,iBAAA,EACAd,EAAAe,aACA5K,KAAA0K,kBAAA1K,KAAA2K,kBACA3K,KAAA4K,aAAAf,EAAAe,WAGA5K,KAAA4K,YAAA,EAEAf,EAAAwE,eACArO,KAAA6K,iBAAAhB,EAAAwE,cAAAF,IACAnO,KAAA8K,iBAAAjB,EAAAwE,cAAAD,KAGApO,KAAA6K,iBAAA7K,KAAA8K,iBAAA,EAEA9K,KAAAwK,YAAAX,EAAAyE,SAAAH,IACAnO,KAAAyK,YAAAZ,EAAAyE,SAAAF,IAEApO,KAAA+K,kBAAA3B,EAAA7E,QAAAgK,aAAA1E,EAAA2E,WAEA3E,EAAA4E,KACAzO,KAAAgL,WAAA,kBAAAnB,GAAA4E,KACA5E,EAAA4E,KACArF,EAAA7E,QAAAmK,aAAA7E,EAAA4E,MAGAzO,KAAAgL,WAAA,KAEA4C,EAAAe,UACA3O,KAAAiL,UAAA2C,EAAAe,UAAA9E,EAAAoB,WAEAjL,KAAAiL,UAAApB,EAAAoB,WAAA,KAKAjL,KAAAyL,UAAAzL,KAAA0L,YAAA1L,KAAA2L,YAAA,KACA3L,KAAA4L,iBAAA,EACA/B,EAAA+B,kBAAA/B,EAAA+B,iBAAA,IACA5L,KAAA4L,iBAAA/B,EAAA+B,kBACA5L,KAAA6L,gBAAA,EACA7L,KAAA8L,WAAA,CACA,IAAAJ,GACAC,CAEA,QAAA9B,EAAA0B,WACA,IAAA,OACAvL,KAAAuL,UAAA,OACAvL,KAAAwL,WAAAxL,KAAA4O,UACA,IAAAnD,GAAA5B,EAAA4B,SACAzL,MAAAyL,UAAA,GAAArJ,MAAAyM,UAAApD,EAAAjG,EAAAiG,EAAAhG,EAAAgG,EAAAqD,EAAArD,EAAAsD,EACA,MACA,KAAA,SACA/O,KAAAuL,UAAA,SACAvL,KAAAwL,WAAAxL,KAAAgP,aACAtD,EAAA7B,EAAA6B,YACA1L,KAAA0L,YAAA,GAAAtJ,MAAA6M,OAAAvD,EAAAlG,EAAAkG,EAAAjG,EAAAiG,EAAAxL,EACA,MACA,KAAA,OACAF,KAAAuL,UAAA,OACAvL,KAAAwL,WAAAxL,KAAAkP,WACAxD,EAAA7B,EAAA6B,YACA1L,KAAA0L,YAAA,GAAAtJ,MAAA6M,OAAAvD,EAAAlG,EAAAkG,EAAAjG,EAAAiG,EAAAxL,GACAF,KAAA0L,YAAAyD,UAAAzD,EAAA0D,IACA,MACA,KAAA,QACApP,KAAAuL,UAAA,QACAvL,KAAAwL,WAAAxL,KAAAqP,YACArP,KAAA6L,gBAAAhC,EAAAgC,gBACA7L,KAAA8L,WAAAjC,EAAAiC,WAAAjC,EAAAiC,WAAA,CACA,MACA,KAAA,SACA9L,KAAAuL,UAAA,SACAvL,KAAAwL,WAAAxL,KAAAsP,aACA3D,EAAA9B,EAAA8B,YACA3L,KAAA2L,YAAA,GAAAnC,GAAAjF,QAAAoH,EAAAlH,cAAAkH,EAAAjH,OAAAiH,EAAAhH,iBACA,MACA,KAAA,QAIA,QACA3E,KAAAuL,UAAA,QACAvL,KAAAwL,WAAAxL,KAAAuP,YAIAvP,KAAAwP,UAAA3F,EAAA2F,UACAxP,KAAAmL,YAAA,gBAAAtB,GAAAsB,aAAAtB,EAAAsB,YAAA,EAAAtB,EAAAsB,YAAA,EAEAnL,KAAAqL,gBAAAxB,EAAAwB,kBAAA,EAEArL,KAAAoL,aAAAvB,EAAAuB,aAAA,EAAAvB,EAAAuB,aAAA,IAEApL,KAAAqM,YAAAxC,EAAAwC,UAEArM,KAAA+L,SAAA,EACA/L,KAAAgM,SAAA,GAAA5J,MAAA4E,MACAhH,KAAAsL,SAAA,GAAAlJ,MAAA4E,MAAA6C,EAAA4F,IAAAjK,EAAAqE,EAAA4F,IAAAhK,GACAzF,KAAAiM,gBAAAjM,KAAAsL,SAAAoE,QAEA1P,KAAAkM,iBAAA,EAEAlM,KAAAwM,YAAA,EACAxM,KAAA2P,SAAAC,KAAA/F,EAAA8F,QAAA9F,EAAA8F,KACA3P,KAAA6P,eAAAD,KAAA/F,EAAAgG,cAAAhG,EAAAgG,aAQAnG,EAAA5H,UAAAqL,QAAA,SAAAK,GACAA,EAAAC,OACAD,EAAAC,KAAAqC,KAAAtC,EAAAsC,MACAtC,EAAAsC,OACAtC,EAAAsC,KAAArC,KAAAD,EAAAC,MACAD,GAAAxN,KAAA2M,uBACA3M,KAAA2M,qBAAAa,EAAAsC,MACAtC,GAAAxN,KAAA0M,wBACA1M,KAAA0M,sBAAAc,EAAAC,MAEAD,EAAAsC,KAAA,KACAtC,EAAAC,KAAAzN,KAAA4M,WACA5M,KAAA4M,WAAAY,EAEAA,EAAAN,QACAM,EAAAN,OAAA6C,YAAAvC,KAEAxN,KAAAsM,eAOA5C,EAAA5H,UAAAsL,OAAA,SAAA4C,GACA,GAAAhQ,KAAA+L,UAAAiE,EAAA,CAGA,GAAAC,GAAAD,EAAAhQ,KAAA+L,QACA/L,MAAA+L,SAAAiE,EAEA5G,EAAA7E,QAAA2L,YAAAD,EAAAjQ,KAAAsL,UAEAtL,KAAAmM,aAAA,IAQAzC,EAAA5H,UAAAuL,eAAA,SAAA7H,EAAAC,GACAzF,KAAAmM,aAAA,EACAnM,KAAAsL,SAAA9F,EAAAA,EACAxF,KAAAsL,SAAA7F,EAAAA,GASAiE,EAAA5H,UAAAwL,eAAA,SAAA9H,EAAAC,GACAzF,KAAAmM,aAAA,EACAnM,KAAAgM,SAAAxG,EAAAA,EACAxF,KAAAgM,SAAAvG,EAAAA,GAQAiE,EAAA5H,UAAAqO,sBAAA,WACAnQ,KAAAkM,iBAAA,GAEA7K,OAAAW,eAAA0H,EAAA5H,UAAA,QAMAoF,IAAA,WAAA,MAAAlH,MAAAuM,OACAnF,IAAA,SAAAnF,GACAjC,KAAAuM,QAAAtK,EACAjC,KAAAyM,aAAAzM,KAAAqL,iBAEA/D,YAAA,EACAC,cAAA,IAGAlG,OAAAW,eAAA0H,EAAA5H,UAAA,cAMAoF,IAAA,WAAA,MAAAlH,MAAA+M,aACA3F,IAAA,SAAAnF,GACAjC,KAAA+M,cAAA9K,EACAqH,EAAA8G,OAAApQ,KAAAmD,OAAAnD,OAEAA,KAAA+M,aAAA9K,GACAqH,EAAA+G,IAAArQ,KAAAmD,OAAAnD,MAEAA,KAAA+M,cAAA9K,GAEAqF,YAAA,EACAC,cAAA,IAQAmC,EAAA5H,UAAAwO,mBAAA,SAAAC,GACAvQ,KAAA6P,YAAA,EACA7P,KAAA2P,MAAA,EACA3P,KAAAgN,sBAAA,EACAhN,KAAAiN,kBAAAsD,GAOA7G,EAAA5H,UAAA0O,SAAA,SAAAD,GACAvQ,KAAA2P,MAAA,EACA3P,KAAAiN,kBAAAsD,GAOA7G,EAAA5H,UAAAqB,OAAA,SAAAC,GAMA,GALApD,KAAA+M,cACA3J,EAAAA,EAAAhB,KAAAqO,SAAAC,YAAA,KAIA1Q,KAAAoM,QAAA,CAGA,GAAA7L,GAAAiN,EAAAC,CACA,KAAAD,EAAAxN,KAAA0M,sBAAAc,EAAAA,EAAAC,EACAA,EAAAD,EAAAC,KACAD,EAAArK,OAAAC,EAEA,IAAAuN,GAAAC,CAEA5Q,MAAAkM,kBACAyE,EAAA3Q,KAAAiM,gBAAAzG,EACAoL,EAAA5Q,KAAAiM,gBAAAxG,EAGA,IAAAoL,GAAA7Q,KAAAgM,SAAAxG,EAAAxF,KAAAsL,SAAA9F,EACAsL,EAAA9Q,KAAAgM,SAAAvG,EAAAzF,KAAAsL,SAAA7F,CAEA,IAAAzF,KAAAuM,MAIA,IAFAvM,KAAAwM,aAAApJ,EAAA,EAAA,EAAAA,EAEApD,KAAAwM,aAAA,GAAA,CAEA,GAAAxM,KAAAyM,aAAA,IACAzM,KAAAyM,cAAAzM,KAAAkL,WACAlL,KAAAyM,cAAA,GAAA,CACAzM,KAAAwM,YAAA,EACAxM,KAAAyM,aAAA,EACAzM,KAAA2P,MAAA,CACA,OAIA,GAAA3P,KAAAsM,eAAAtM,KAAAoL,aACApL,KAAAwM,aAAAxM,KAAAkL,eADA,CAKA,GAAAoD,OAAA,EAMA,IAJAA,EADAtO,KAAAwK,aAAAxK,KAAAyK,YACAzK,KAAAwK,YAEA7E,KAAAoL,UAAA/Q,KAAAyK,YAAAzK,KAAAwK,aAAAxK,KAAAwK,aAEAxK,KAAAwM,YAAA8B,EAAA,CAGA,GAAA0C,OAAA,GAAAC,MAAA,EACA,IAAAjR,KAAAkM,iBAAAlM,KAAAmM,YAAA,CAEA,GAAA9I,GAAA,EAAArD,KAAAwM,YAAApJ,CACA4N,IAAAH,EAAAF,GAAAtN,EAAAsN,EACAM,GAAAH,EAAAF,GAAAvN,EAAAuN,MAIAI,GAAAH,EACAI,EAAAH,CAGAvQ,GAAA,CACA,KAAA,GAAAqG,GAAAjB,KAAAwI,IAAAnO,KAAA4L,iBAAA5L,KAAAoL,aAAApL,KAAAsM,eAAA/L,EAAAqG,IAAArG,EAEA,KAAAP,KAAAmL,YAAA,GAAAxF,KAAAoL,UAAA/Q,KAAAmL,aAAA,CAGA,GAAArK,OAAA,EAqDA,IApDAd,KAAA4M,YACA9L,EAAAd,KAAA4M,WACA5M,KAAA4M,WAAA5M,KAAA4M,WAAAa,KACA3M,EAAA2M,KAAA,MAGA3M,EAAA,GAAAd,MAAAkR,oBAAAlR,MAGAA,KAAA4J,eAAA5I,OAAA,EACAF,EAAAmC,SAAAjD,KAAA4J,eAAAjE,KAAAa,MAAAb,KAAAoL,SAAA/Q,KAAA4J,eAAA5I,UAKAF,EAAAmC,SAAAjD,KAAA4J,eAAA,IAGA9I,EAAAqQ,UAAAC,MAAApR,KAAA+J,YACA,GAAA/J,KAAAiK,yBACAnJ,EAAAuQ,gBAAA1L,KAAAoL,UAAA,EAAA/Q,KAAAiK,wBAAAjK,KAAAiK,wBAEAnJ,EAAAwQ,UAAAF,MAAApR,KAAAgK,YACAlJ,EAAAoJ,aAAA1E,EAAAxF,KAAAkK,aAAA1E,EACA1E,EAAAoJ,aAAAzE,EAAAzF,KAAAkK,aAAAzE,EACA3E,EAAAqJ,SAAAnK,KAAAmK,SACA,GAAAnK,KAAAsK,yBACAxJ,EAAAyQ,gBAAA5L,KAAAoL,UAAA,EAAA/Q,KAAAsK,wBAAAtK,KAAAsK,wBAEAxJ,EAAA0Q,UAAAJ,MAAApR,KAAAqK,YACAvJ,EAAA2Q,UAAAL,MAAApR,KAAAuK,YAEAvK,KAAA6K,kBAAA7K,KAAA8K,iBACAhK,EAAAuN,cAAArO,KAAA6K,iBAEA/J,EAAAuN,cAAA1I,KAAAoL,UAAA/Q,KAAA8K,iBAAA9K,KAAA6K,kBAAA7K,KAAA6K,iBACA/J,EAAA8J,WAAA5K,KAAA4K,WAEA9J,EAAAkC,QAAAsL,EAEAxN,EAAA0N,UAAAxO,KAAA+K,kBAEAjK,EAAA2N,KAAAzO,KAAAgL,WAEAlK,EAAAmK,UAAAjL,KAAAiL,UAEAjL,KAAAwL,WAAA1K,EAAAkQ,EAAAC,EAAA1Q,GAEAO,EAAAgC,OAEAhC,EAAAqC,QAAAnD,KAAAwM,aAEA1L,EAAAoM,OAMA,CAGA,GAAAwE,GAAA1R,KAAAoM,QAAAsF,QAEA,IAAAA,EAAA,IAAA5Q,EACA4Q,EAAAC,YACA,IAAAD,EAAAA,EAAA1Q,OAAA,IAAAF,EACA4Q,EAAAE,UACA,CACA,GAAArL,GAAAmL,EAAAG,QAAA/Q,EACA4Q,GAAAI,OAAAvL,EAAA,GAEAvG,KAAAqM,UACAqF,EAAAK,QAAAjR,GAEA4Q,EAAAvN,KAAArD,OArBAd,MAAAqM,UACArM,KAAAoM,QAAA4F,WAAAlR,EAAA,GAEAd,KAAAoM,QAAA6F,SAAAnR,EAqBAd,MAAA2M,sBACA3M,KAAA2M,qBAAAc,KAAA3M,EACAA,EAAAgP,KAAA9P,KAAA2M,qBACA3M,KAAA2M,qBAAA7L,GAGAd,KAAA2M,qBAAA3M,KAAA0M,sBAAA5L,IAEAd,KAAAsM,eAIAtM,KAAAwM,aAAAxM,KAAAkL,YAIAlL,KAAAmM,cACAnM,KAAAiM,gBAAAzG,EAAAqL,EACA7Q,KAAAiM,gBAAAxG,EAAAqL,EACA9Q,KAAAkM,iBAAA,EACAlM,KAAAmM,aAAA,GAGAnM,KAAAuM,OAAAvM,KAAA0M,wBACA1M,KAAAiN,mBACAjN,KAAAiN,oBAEAjN,KAAAgN,sBACAhN,KAAA0D,aAaAgG,EAAA5H,UAAAyN,YAAA,SAAAzO,EAAAkQ,EAAAC,GAGAjR,KAAA0K,kBAAA1K,KAAA2K,iBACA7J,EAAAiL,SAAA/L,KAAA0K,iBAAA1K,KAAA+L,SAEAjL,EAAAiL,SAAApG,KAAAoL,UAAA/Q,KAAA2K,iBAAA3K,KAAA0K,kBAAA1K,KAAA0K,iBAAA1K,KAAA+L,SAEAjL,EAAAoR,SAAA1M,EAAAwL,EACAlQ,EAAAoR,SAAAzM,EAAAwL,GAWAvH,EAAA5H,UAAA8M,WAAA,SAAA9N,EAAAkQ,EAAAC,GAGAjR,KAAA0K,kBAAA1K,KAAA2K,iBACA7J,EAAAiL,SAAA/L,KAAA0K,iBAAA1K,KAAA+L,SAEAjL,EAAAiL,SAAApG,KAAAoL,UAAA/Q,KAAA2K,iBAAA3K,KAAA0K,kBAAA1K,KAAA0K,iBAAA1K,KAAA+L,SAEAtC,EAAAjE,EAAAG,KAAAoL,SAAA/Q,KAAAyL,UAAA0G,MAAAnS,KAAAyL,UAAAjG,EACAiE,EAAAhE,EAAAE,KAAAoL,SAAA/Q,KAAAyL,UAAA2G,OAAApS,KAAAyL,UAAAhG,EACA,IAAAzF,KAAA+L,UACA3C,EAAA7E,QAAA2L,YAAAlQ,KAAA+L,SAAAtC,GACA3I,EAAAoR,SAAA1M,EAAAwL,EAAAvH,EAAAjE,EACA1E,EAAAoR,SAAAzM,EAAAwL,EAAAxH,EAAAhE,GAWAiE,EAAA5H,UAAAkN,aAAA,SAAAlO,EAAAkQ,EAAAC,GAGAjR,KAAA0K,kBAAA1K,KAAA2K,iBACA7J,EAAAiL,SAAA/L,KAAA0K,iBAAA1K,KAAA+L,SAEAjL,EAAAiL,SAAApG,KAAAoL,UAAA/Q,KAAA2K,iBAAA3K,KAAA0K,kBACA1K,KAAA0K,iBAAA1K,KAAA+L,SAEAtC,EAAAjE,EAAAG,KAAAoL,SAAA/Q,KAAA0L,YAAA2G,OACA5I,EAAAhE,EAAA,EAEA2D,EAAA7E,QAAA2L,YAAA,IAAAvK,KAAAoL,SAAAtH,GAEAA,EAAAjE,GAAAxF,KAAA0L,YAAAlG,EACAiE,EAAAhE,GAAAzF,KAAA0L,YAAAjG,EAEA,IAAAzF,KAAA+L,UACA3C,EAAA7E,QAAA2L,YAAAlQ,KAAA+L,SAAAtC,GAEA3I,EAAAoR,SAAA1M,EAAAwL,EAAAvH,EAAAjE,EACA1E,EAAAoR,SAAAzM,EAAAwL,EAAAxH,EAAAhE,GAWAiE,EAAA5H,UAAAoN,WAAA,SAAApO,EAAAkQ,EAAAC,GACA,GAAAvF,GAAA1L,KAAA0L,WAGA1L,MAAA0K,kBAAA1K,KAAA2K,iBACA7J,EAAAiL,SAAA/L,KAAA0K,iBAAA1K,KAAA+L,SAEAjL,EAAAiL,SAAApG,KAAAoL,UAAA/Q,KAAA2K,iBAAA3K,KAAA0K,kBACA1K,KAAA0K,iBAAA1K,KAAA+L,SAEAL,EAAAyD,YAAAzD,EAAA2G,OACA5I,EAAAjE,EAAAG,KAAAoL,UAAArF,EAAA2G,OAAA3G,EAAAyD,WACAzD,EAAAyD,UAGA1F,EAAAjE,EAAAkG,EAAA2G,OACA5I,EAAAhE,EAAA,CAEA,IAAA6M,GAAA,IAAA3M,KAAAoL,QACAjQ,GAAAiL,UAAAuG,EACAlJ,EAAA7E,QAAA2L,YAAAoC,EAAA7I,GAEAA,EAAAjE,GAAAxF,KAAA0L,YAAAlG,EACAiE,EAAAhE,GAAAzF,KAAA0L,YAAAjG,EAEA,IAAAzF,KAAA+L,UACA3C,EAAA7E,QAAA2L,YAAAlQ,KAAA+L,SAAAtC,GAEA3I,EAAAoR,SAAA1M,EAAAwL,EAAAvH,EAAAjE,EACA1E,EAAAoR,SAAAzM,EAAAwL,EAAAxH,EAAAhE,GAWAiE,EAAA5H,UAAAwN,aAAA,SAAAxO,EAAAkQ,EAAAC,GACA,GAAAtF,GAAA3L,KAAA2L,WAGA3L,MAAA0K,kBAAA1K,KAAA2K,iBACA7J,EAAAiL,SAAA/L,KAAA0K,iBAAA1K,KAAA+L,SAEAjL,EAAAiL,SAAApG,KAAAoL,UAAA/Q,KAAA2K,iBAAA3K,KAAA0K,kBACA1K,KAAA0K,iBAAA1K,KAAA+L,QAEA,IAAAxF,GAAAoF,EAAAtF,SAAAV,KAAAoL,SACAtH,GAAAjE,EAAAmG,EAAA4G,OAAAhM,GAAAf,EACAiE,EAAAhE,EAAAkG,EAAA4G,OAAAhM,GAAAd,CAEA,IAAA+M,GAAA7G,EAAAlF,WAAAF,GAAAU,IACAnG,GAAAiL,UAAA3J,KAAAqQ,WAAA9M,KAAAI,MAAAyM,EAAA/M,EAAA+M,EAAAhN,GAEA,IAAAxF,KAAA+L,UACA3C,EAAA7E,QAAA2L,YAAAlQ,KAAA+L,SAAAtC,GAGA3I,EAAAoR,SAAA1M,EAAAwL,EAAAvH,EAAAjE,EACA1E,EAAAoR,SAAAzM,EAAAwL,EAAAxH,EAAAhE,GAWAiE,EAAA5H,UAAAuN,YAAA,SAAAvO,EAAAkQ,EAAAC,EAAA1Q,GAGA,IAAAP,KAAA6L,gBACA/K,EAAAiL,SAAA,IAAApG,KAAAoL,SAEAjQ,EAAAiL,SAAA/L,KAAA8L,WAAA9L,KAAA6L,gBAAAtL,EAAAP,KAAA+L,SAEAjL,EAAAoR,SAAA1M,EAAAwL,EACAlQ,EAAAoR,SAAAzM,EAAAwL,GAMAvH,EAAA5H,UAAAyL,QAAA,WACA,GAAAC,GAAAC,CACA,KAAAD,EAAAxN,KAAA0M,sBAAAc,EAAAA,EAAAC,EACAA,EAAAD,EAAAC,KACAzN,KAAAmN,QAAAK,GACAA,EAAAN,QACAM,EAAAN,OAAA6C,YAAAvC,EAEAxN,MAAA0M,sBAAA1M,KAAA2M,qBAAA,KACA3M,KAAAsM,cAAA,GAMA5C,EAAA5H,UAAA4B,QAAA,WAEA1D,KAAA6P,YAAA,EAEA7P,KAAAuN,SAGA,KAAA,GADAE,GACAD,EAAAxN,KAAA4M,WAAAY,EAAAA,EAAAC,EAEAA,EAAAD,EAAAC,KACAD,EAAA9J,SAEA1D,MAAA4M,WAAA5M,KAAAoM,QAAApM,KAAA4J,eAAA5J,KAAAsL,SAAAtL,KAAAgM,SACAhM,KAAAuK,WAAAvK,KAAAqK,WAAArK,KAAA+J,WAAA/J,KAAAgK,WACAhK,KAAAgL,WAAAhL,KAAAiN,kBAAA,MAEAvD,IAEAlK,GAAA+E,QAAAmF,gGC/0BA,YACA,IAAAvI,GAAAnB,MAAAA,KAAAmB,WAAA,WACA,GAAAC,GAAAC,OAAAC,iBACAC,uBAAAC,QAAA,SAAAC,EAAAC,GAAAD,EAAAF,UAAAG,IACA,SAAAD,EAAAC,GAAA,IAAA,GAAAZ,KAAAY,GAAAA,EAAAC,eAAAb,KAAAW,EAAAX,GAAAY,EAAAZ,IACA,OAAA,UAAAW,EAAAC,GAEA,QAAAE,KAAA5B,KAAA6B,YAAAJ,EADAL,EAAAK,EAAAC,GAEAD,EAAAK,UAAA,OAAAJ,EAAAL,OAAAU,OAAAL,IAAAE,EAAAE,UAAAJ,EAAAI,UAAA,GAAAF,OAGAP,QAAAW,eAAAxC,EAAA,cAAAyC,OAAA,GACA,IAAAmH,GAAAlI,EAAA,mBACAwR,EAAAxR,EAAA,kBACAyR,EAAAvQ,KAAAuQ,OASAC,EAAA,SAAAtQ,GAEA,QAAAsQ,GAAArQ,GACA,GAAAC,GAGAF,EAAAvB,KAAAf,OAAAA,IAwGA,OAvGAwC,GAAAD,QAAAA,EAEAC,EAAAqQ,OAAArN,EAAAhD,EAAAqQ,OAAApN,EAAA,GACAjD,EAAAsQ,SAAA,GAAA1Q,MAAA4E,MACAxE,EAAAQ,QAAA,EACAR,EAAAuQ,IAAA,EACAvQ,EAAAiM,KAAA,KACAjM,EAAAyI,UAAA,KACAzI,EAAA2O,UAAA,GAAAuB,GAAAnO,QACA/B,EAAA8O,UAAA,GAAAoB,GAAAnO,QACA/B,EAAA6O,gBAAA,EAKA7O,EAAA0H,aAAA,GAAA9H,MAAA4E,MAOAxE,EAAA2H,SAAAC,IAKA5H,EAAAgP,UAAA,GAAAkB,GAAAnO,QAKA/B,EAAA+O,gBAAA,EAKA/O,EAAAiP,UAAA,GAAAiB,GAAAnO,SAAA,GAMA/B,EAAAwQ,UAAA,EAMAxQ,EAAAyQ,UAAA,EAMAzQ,EAAA0Q,UAAA,EAOA1Q,EAAA2Q,iBAAA,EAMA3Q,EAAA4Q,UAAA,EAOA5Q,EAAA6Q,mBAAA,EAMA7Q,EAAA8Q,aAAA,EAMA9Q,EAAAiL,KAAA,KAMAjL,EAAAsN,KAAA,KAEAtN,EAAAM,KAAAN,EAAAM,KACAN,EAAAO,cAAA6P,EAAA9Q,UAAAgB,KACAN,EAAAW,OAAAX,EAAAW,OACAX,EAAAc,gBAAAsP,EAAA9Q,UAAAqB,OACAX,EAAA+Q,eAAAjR,EAAAR,UAAA4B,QACAlB,EAAAmB,iBAAAiP,EAAA9Q,UAAA4B,QACAlB,EAAAS,SAAAT,EAAAS,SACAT,EAAAgR,KAAAhR,EAAAgR,KACAhR,EA0LA,MAvSArB,GAAAyR,EAAAtQ,GAoHAsQ,EAAA9Q,UAAAgB,KAAA,WAEA9C,KAAA+S,IAAA,EAEA/S,KAAA8S,SAAAtN,EAAAxF,KAAAsR,UAAAmC,QAAAxR,MAAAjC,KAAAqR,gBACArR,KAAA8S,SAAArN,EAAA,EACA2D,EAAA7E,QAAA2L,YAAAlQ,KAAA+L,SAAA/L,KAAA8S,UACA9S,KAAA4K,WACA5K,KAAA+L,SAAA,EAIA/L,KAAA+L,UAAA3C,EAAA7E,QAAAmP,YAGA1T,KAAAqO,eAAAjF,EAAA7E,QAAAmP,YAEA1T,KAAA6N,MAAA7N,KAAAmR,UAAAsC,QAAAxR,MAEAjC,KAAAgO,MAAAxI,EAAAxF,KAAAgO,MAAAvI,EAAAzF,KAAAwR,UAAAiC,QAAAxR,MAEAjC,KAAAgT,WAAAhT,KAAAmR,UAAAsC,QAAAhG,KACAzN,KAAAkT,WAAAlT,KAAAsR,UAAAmC,QAAAhG,KACAzN,KAAAiT,WAAAjT,KAAAwR,UAAAiC,QAAAhG,KACAzN,KAAAoT,WAAApT,KAAAyR,UAAAgC,QAAAhG,KACAzN,KAAAmT,gBAAA,IAAAnT,KAAAkK,aAAA1E,GAAA,IAAAxF,KAAAkK,aAAAzE,EAEAzF,KAAAqT,kBAAArT,KAAAkT,UAAA,IAAAlT,KAAAsR,UAAAmC,QAAAxR,OAAAjC,KAAAmT,gBAEAnT,KAAAsT,aAAA,EAAAtT,KAAAgD,OAEA,IAAAiL,GAAAjO,KAAAyR,UAAAgC,QAAAxR,KACAjC,MAAA2T,KAAAvK,EAAA7E,QAAAqP,qBAAA3F,EAAA/N,EAAA+N,EAAArO,EAAAqO,EAAAvM,GAEA1B,KAAA6T,SAAA,GAQAjB,EAAA9Q,UAAAmB,SAAA,SAAAC,GACAlD,KAAAwD,QAAAN,GAAAd,KAAAD,QAAAsB,OASAmP,EAAA9Q,UAAAqB,OAAA,SAAAC,GAIA,GAFApD,KAAA+S,KAAA3P,EAEApD,KAAA+S,KAAA/S,KAAAgD,SAAAhD,KAAA+S,IAAA,EAEA,MADA/S,MAAAwT,QACA,CAGA,IAAAnQ,GAAArD,KAAA+S,IAAA/S,KAAAsT,YAiBA,IAhBAtT,KAAAyO,OAIApL,EAHA,GAAArD,KAAAyO,KAAAzN,OAGAhB,KAAAyO,KAAApL,EAAA,EAAA,EAAA,GAKArD,KAAAyO,KAAApL,IAIArD,KAAAgT,WACAhT,KAAA6N,MAAA7N,KAAAmR,UAAA2C,YAAAzQ,IAEArD,KAAAiT,SAAA,CACA,GAAAjF,GAAAhO,KAAAwR,UAAAsC,YAAAzQ,GAAArD,KAAAuR,eACAvR,MAAAgO,MAAAxI,EAAAxF,KAAAgO,MAAAvI,EAAAuI,EAGA,GAAAhO,KAAAqT,kBAAA,CAEA,GAAArT,KAAAkT,SAAA,CACA,GAAAnF,GAAA/N,KAAAsR,UAAAwC,YAAAzQ,GAAArD,KAAAqR,eACAjI,GAAA7E,QAAAwP,UAAA/T,KAAA8S,UACA1J,EAAA7E,QAAAyP,QAAAhU,KAAA8S,SAAA/E,OAEA,IAAA/N,KAAAmT,kBACAnT,KAAA8S,SAAAtN,GAAAxF,KAAAkK,aAAA1E,EAAApC,EACApD,KAAA8S,SAAArN,GAAAzF,KAAAkK,aAAAzE,EAAArC,EACApD,KAAAmK,UAAA,CACA,GAAA8J,GAAA7K,EAAA7E,QAAAvD,OAAAhB,KAAA8S,SAGAmB,GAAAjU,KAAAmK,UACAf,EAAA7E,QAAAyP,QAAAhU,KAAA8S,SAAA9S,KAAAmK,SAAA8J,GAKAjU,KAAAkS,SAAA1M,GAAAxF,KAAA8S,SAAAtN,EAAApC,EACApD,KAAAkS,SAAAzM,GAAAzF,KAAA8S,SAAArN,EAAArC,EAaA,MAVApD,MAAAoT,WACApT,KAAA2T,KAAA3T,KAAAyR,UAAAqC,YAAAzQ,IAGA,IAAArD,KAAAqO,cACArO,KAAA+L,UAAA/L,KAAAqO,cAAAjL,EAEApD,KAAAkK,eAAAlK,KAAA4K,aACA5K,KAAA+L,SAAApG,KAAAI,MAAA/F,KAAA8S,SAAArN,EAAAzF,KAAA8S,SAAAtN,IAEAnC,GAOAuP,EAAA9Q,UAAA0R,KAAA,WACAxT,KAAAuC,QAAA4K,QAAAnN,OAMA4S,EAAA9Q,UAAA4B,QAAA,WACA1D,KAAAkN,QACAlN,KAAAkN,OAAA6C,YAAA/P,MACAA,KAAAuT,iBACAvT,KAAAuC,QAAAvC,KAAA8S,SAAA9S,KAAAyR,UAAAzR,KAAAwR,UAAAxR,KAAAmR,UACAnR,KAAAsR,UAAAtR,KAAAyO,KAAAzO,KAAAyN,KAAAzN,KAAA8P,KAAA,MAYA8C,EAAAhP,SAAA,SAAAV,GAEA,GAAA3C,EACA,KAAAA,EAAA2C,EAAAlC,OAAAT,GAAA,IAAAA,EACA,gBAAA2C,GAAA3C,KACA2C,EAAA3C,GAAA6B,KAAAD,QAAAiC,UAAAlB,EAAA3C,IAIA,IAAA6I,EAAA7E,QAAA2P,QACA,IAAA3T,EAAA2C,EAAAlC,OAAA,EAAAT,EAAA,IAAAA,EACA,GAAA2C,EAAA3C,GAAA4T,aAAAjR,EAAA3C,EAAA,GAAA4T,YAAA,CACAtU,OAAAuU,SACAA,QAAAC,KAAA,+FACA,OAIA,MAAAnR,IAUA0P,EAAAjE,UAAA,SAAA1D,GACA,MAAAA,IAEA2H,GACAD,EACAnT,GAAA+E,QAAAqO,gECjUA,YACAvR,QAAAW,eAAAxC,EAAA,cAAAyC,OAAA,GACA,IAAAqS,GAAAlS,KAAAkS,YACAjL,EAAAnI,EAAA,kBAOAqT,GAOAL,SAAA,EACAR,YAAA/N,KAAA6O,GAAA,IAQAtE,YAAA,SAAAoC,EAAAxR,GACA,GAAAwR,EAAA,CAEAA,GAAAiC,EAAAb,WACA,IAAAe,GAAA9O,KAAA+O,IAAApC,GACA9R,EAAAmF,KAAAgP,IAAArC,GACAsC,EAAA9T,EAAA0E,EAAAhF,EAAAM,EAAA2E,EAAAgP,EACAI,EAAA/T,EAAA0E,EAAAiP,EAAA3T,EAAA2E,EAAAjF,CACAM,GAAA0E,EAAAoP,EACA9T,EAAA2E,EAAAoP,IAWAjB,qBAAA,SAAA1T,EAAAN,EAAA8B,GACA,MAAAxB,IAAA,GAAAN,GAAA,EAAA8B,GAQAqS,UAAA,SAAA9N,GACA,GAAA6O,GAAA,EAAAP,EAAAvT,OAAAiF,EACAA,GAAAT,GAAAsP,EACA7O,EAAAR,GAAAqP,GASAd,QAAA,SAAA/N,EAAAhE,GACAgE,EAAAT,GAAAvD,EACAgE,EAAAR,GAAAxD,GASAjB,OAAA,SAAAiF,GACA,MAAAN,MAAAC,KAAAK,EAAAT,EAAAS,EAAAT,EAAAS,EAAAR,EAAAQ,EAAAR,IAYAsP,SAAA,SAAA9G,EAAAnK,GACAA,IACAA,MACA,KAAAmK,EAAA+G,OAAA,GACA/G,EAAAA,EAAAgH,OAAA,GACA,IAAAhH,EAAA4D,QAAA,QACA5D,EAAAA,EAAAgH,OAAA,GACA,IAAApH,EAUA,OATA,IAAAI,EAAAjN,SACA6M,EAAAI,EAAAgH,OAAA,EAAA,GACAhH,EAAAA,EAAAgH,OAAA,IAEAnR,EAAA5D,EAAAgV,SAAAjH,EAAAgH,OAAA,EAAA,GAAA,IACAnR,EAAAlE,EAAAsV,SAAAjH,EAAAgH,OAAA,EAAA,GAAA,IACAnR,EAAApC,EAAAwT,SAAAjH,EAAAgH,OAAA,EAAA,GAAA,IACApH,IACA/J,EAAAnD,EAAAuU,SAAArH,EAAA,KACA/J,GAYA4K,aAAA,SAAA7F,GACA,GAAAsM,GAAAtM,EAAA7H,OACAoU,EAAA,EAAAD,CAOA,OAAA,UAAAE,GACA,GAAAhV,GAAAoU,EACAlU,EAAA4U,EAAAE,EAAA,CAGA,OAFAhV,IAAAgV,EAAA9U,EAAA6U,GAAAD,EACAV,EAAA5L,EAAAtI,IAAAsI,EAAAsM,EAAA,GACAV,EAAAA,EAAApU,GAAA,GAAA,EAAAA,IAAAoU,EAAAa,GAAAb,EAAAA,GAAApU,GAAAoU,EAAAtU,EAAAsU,EAAAA,MAUAlG,aAAA,SAAAgH,GACA,IAAAA,EACA,MAAAjB,GAAAkB,MAEA,KADAD,EAAAA,EAAAE,cACAF,EAAA1D,QAAA,MAAA,GACA0D,EAAAA,EAAAG,QAAA,IAAA,IACA,OAAApB,GAAAiB,IAAAjB,EAAAkB,QAYAG,sBAAA,SAAAC,EAAAC,OACA,KAAAA,IAAAA,EAAA,KACA,gBAAAA,IAAAA,GAAA,KACAA,EAAA,GACA,IAAAC,GAAA,GAAAzM,GAAA9E,QAAAqR,EAAA,GAAA3T,MAAA2T,EAAA,GAAAP,KACAS,GAAAC,WAAA,CAKA,KAAA,GAJAC,GAAAF,EACArC,EAAAmC,EAAA,GACAK,EAAA,EACAxI,EAAAmI,EAAAK,GACA1V,EAAA,EAAAA,EAAAsV,IAAAtV,EAAA,CAGA,IAFA,GAAA8C,GAAA9C,EAAAsV,EAEAxS,EAAAoK,EAAA4H,MACA5B,EAAAhG,EACAA,EAAAmI,IAAAK,EAGA5S,IAAAA,EAAAoQ,EAAA4B,OAAA5H,EAAA4H,KAAA5B,EAAA4B,KACA,IAAAa,GAAA3B,EAAAQ,SAAAtB,EAAAxR,OACAkU,EAAA5B,EAAAQ,SAAAtH,EAAAxL,OACA6B,IACAA,GAAA5D,GAAAiW,EAAAjW,EAAAgW,EAAAhW,GAAAmD,EAAA6S,EAAAhW,EACA4D,EAAAlE,GAAAuW,EAAAvW,EAAAsW,EAAAtW,GAAAyD,EAAA6S,EAAAtW,EACAkE,EAAApC,GAAAyU,EAAAzU,EAAAwU,EAAAxU,GAAA2B,EAAA6S,EAAAxU,EACAsU,EAAAvI,KAAA,GAAApE,GAAA9E,QAAAT,EAAAvD,EAAAsV,GACAG,EAAAA,EAAAvI,KAIA,MAAAqI,IAGAtW,GAAA+E,QAAAgQ,4CCnMA,YACA,IAAApT,GAAAnB,MAAAA,KAAAmB,WAAA,WACA,GAAAC,GAAAC,OAAAC,iBACAC,uBAAAC,QAAA,SAAAC,EAAAC,GAAAD,EAAAF,UAAAG,IACA,SAAAD,EAAAC,GAAA,IAAA,GAAAZ,KAAAY,GAAAA,EAAAC,eAAAb,KAAAW,EAAAX,GAAAY,EAAAZ,IACA,OAAA,UAAAW,EAAAC,GAEA,QAAAE,KAAA5B,KAAA6B,YAAAJ,EADAL,EAAAK,EAAAC,GAEAD,EAAAK,UAAA,OAAAJ,EAAAL,OAAAU,OAAAL,IAAAE,EAAAE,UAAAJ,EAAAI,UAAA,GAAAF,OAGAP,QAAAW,eAAAxC,EAAA,cAAAyC,OAAA,GACA,IAAAmH,GAAAlI,EAAA,mBACAgB,EAAAhB,EAAA,cAKAuI,EAAA,GAAArH,MAAA4E,MAGAoP,GACA,MACA,OACA,MACA,QACA,QACA,OACA,IACA,KACA,MACA,MACA,MACA,OACA,OACA,OACA,QACA,OAGAC,EAAA,GAAAC,SAGA,yCACAC,OAAAH,GAAAI,KAAA,KAAA,KAWAC,EAAA,SAAAC,GAEA,IAAA,GADAC,GAAAD,EAAAE,MAAAP,GACA9V,EAAAoW,EAAA3V,OAAA,EAAAT,GAAA,IAAAA,EACA6V,EAAAvE,QAAA8E,EAAApW,KAAA,IACAoW,EAAApW,GAAA,QAAAoW,EAAApW,GAGA,OADAmW,GAAAC,EAAAH,KAAA,IACA,GAAAK,UAAA,IAAA,UAAAH,EAAA,MA2BAI,EAAA,SAAAxU,GAEA,QAAAwU,GAAAvU,GACA,GAAAC,GAAAF,EAAAvB,KAAAf,KAAAuC,IAAAvC,IAKA,OAJAwC,GAAAuU,KAAA,KACAvU,EAAAwU,gBAAA,EACAxU,EAAAyU,gBAAA,GAAA7U,MAAA4E,MACAxE,EAAA0U,SAAA,EACA1U,EA4FA,MAnGArB,GAAA2V,EAAAxU,GAcAwU,EAAAhV,UAAAgB,KAAA,WAEA9C,KAAAgX,gBAAAhX,KAAA+L,SAEA/L,KAAA+C,gBAEA/C,KAAA+W,KAAA/W,KAAAiL,UAAA8L,KAEA/W,KAAAqT,mBAAArT,KAAA+W,KAEA/W,KAAAkX,SAAA,EAEAlX,KAAAiX,gBAAAzR,EAAAxF,KAAAkS,SAAA1M,EACAxF,KAAAiX,gBAAAxR,EAAAzF,KAAAkS,SAAAzM,GAOAqR,EAAAhV,UAAAqB,OAAA,SAAAC,GACA,GAAAC,GAAArD,KAAAsD,gBAAAF,EAEA,IAAAC,GAAA,GAAArD,KAAA+W,KAAA,CAEA,GAAAhJ,GAAA/N,KAAAsR,UAAAwC,YAAAzQ,GAAArD,KAAAqR,eACArR,MAAAkX,UAAAnJ,EAAA3K,EAEAqG,EAAAjE,EAAAxF,KAAAkX,SACAzN,EAAAhE,EAAAzF,KAAA+W,KAAA/W,KAAAkX,UACA9N,EAAA7E,QAAA2L,YAAAlQ,KAAAgX,gBAAAvN,GACAzJ,KAAAkS,SAAA1M,EAAAxF,KAAAiX,gBAAAzR,EAAAiE,EAAAjE,EACAxF,KAAAkS,SAAAzM,EAAAzF,KAAAiX,gBAAAxR,EAAAgE,EAAAhE,EAEA,MAAApC,IAMAyT,EAAAhV,UAAA4B,QAAA,WACA1D,KAAA2D,mBACA3D,KAAA+W,KAAA/W,KAAAiX,gBAAA,MAYAH,EAAAlT,SAAA,SAAAV,GACA,MAAAhB,GAAAqC,QAAAX,SAAAV,IAWA4T,EAAAnI,UAAA,SAAA1D,GACA,GAAAnH,KACA,IAAAmH,GAAAA,EAAA8L,KACA,IACAjT,EAAAiT,KAAAN,EAAAxL,EAAA8L,MAEA,MAAA5W,GACAiJ,EAAA7E,QAAA2P,SACAE,QAAA+C,MAAA,kDACArT,EAAAiT,KAAA,SAIA3N,GAAA7E,QAAA2P,SACAE,QAAA+C,MAAA,qDACArT,EAAAiT,KAAA,IAEA,OAAAjT,IAEAgT,GACA5U,EAAAqC,QACA/E,GAAA+E,QAAAuS,4DC/LA,YA4CA,SAAAM,GAAA/T,GAGA,MAFArD,MAAAyO,OACApL,EAAArD,KAAAyO,KAAApL,KACArD,KAAAyN,KAAAxL,MAAAjC,KAAAyT,QAAAxR,OAAAoB,EAAArD,KAAAyT,QAAAxR,MAEA,QAAAoV,GAAAhU,GACArD,KAAAyO,OACApL,EAAArD,KAAAyO,KAAApL,GACA,IAAA6S,GAAAlW,KAAAyT,QAAAxR,MAAAkU,EAAAnW,KAAAyN,KAAAxL,MACA/B,GAAAiW,EAAAjW,EAAAgW,EAAAhW,GAAAmD,EAAA6S,EAAAhW,EACAN,GAAAuW,EAAAvW,EAAAsW,EAAAtW,GAAAyD,EAAA6S,EAAAtW,EACA8B,GAAAyU,EAAAzU,EAAAwU,EAAAxU,GAAA2B,EAAA6S,EAAAxU,CACA,OAAA0H,GAAA7E,QAAAqP,qBAAA1T,EAAAN,EAAA8B,GAEA,QAAA4V,GAAAjU,GAIA,IAHArD,KAAAyO,OACApL,EAAArD,KAAAyO,KAAApL,IAEAA,EAAArD,KAAAyN,KAAA4H,MACArV,KAAAyT,QAAAzT,KAAAyN,KACAzN,KAAAyN,KAAAzN,KAAAyN,KAAAA,IAIA,OADApK,IAAAA,EAAArD,KAAAyT,QAAA4B,OAAArV,KAAAyN,KAAA4H,KAAArV,KAAAyT,QAAA4B,OACArV,KAAAyN,KAAAxL,MAAAjC,KAAAyT,QAAAxR,OAAAoB,EAAArD,KAAAyT,QAAAxR,MAEA,QAAAsV,GAAAlU,GAIA,IAHArD,KAAAyO,OACApL,EAAArD,KAAAyO,KAAApL,IAEAA,EAAArD,KAAAyN,KAAA4H,MACArV,KAAAyT,QAAAzT,KAAAyN,KACAzN,KAAAyN,KAAAzN,KAAAyN,KAAAA,IAGApK,IAAAA,EAAArD,KAAAyT,QAAA4B,OAAArV,KAAAyN,KAAA4H,KAAArV,KAAAyT,QAAA4B,KACA,IAAAa,GAAAlW,KAAAyT,QAAAxR,MAAAkU,EAAAnW,KAAAyN,KAAAxL,MACA/B,GAAAiW,EAAAjW,EAAAgW,EAAAhW,GAAAmD,EAAA6S,EAAAhW,EACAN,GAAAuW,EAAAvW,EAAAsW,EAAAtW,GAAAyD,EAAA6S,EAAAtW,EACA8B,GAAAyU,EAAAzU,EAAAwU,EAAAxU,GAAA2B,EAAA6S,EAAAxU,CACA,OAAA0H,GAAA7E,QAAAqP,qBAAA1T,EAAAN,EAAA8B,GAEA,QAAA8V,GAAAnU,GAIA,IAHArD,KAAAyO,OACApL,EAAArD,KAAAyO,KAAApL,IAEArD,KAAAyN,MAAApK,EAAArD,KAAAyN,KAAA4H,MACArV,KAAAyT,QAAAzT,KAAAyN,KACAzN,KAAAyN,KAAAzN,KAAAyN,KAAAA,IAEA,OAAAzN,MAAAyT,QAAAxR,MAEA,QAAAwV,GAAApU,GAIA,IAHArD,KAAAyO,OACApL,EAAArD,KAAAyO,KAAApL,IAEArD,KAAAyN,MAAApK,EAAArD,KAAAyN,KAAA4H,MACArV,KAAAyT,QAAAzT,KAAAyN,KACAzN,KAAAyN,KAAAzN,KAAAyN,KAAAA,IAEA,IAAAyI,GAAAlW,KAAAyT,QAAAxR,KACA,OAAAmH,GAAA7E,QAAAqP,qBAAAsC,EAAAhW,EAAAgW,EAAAtW,EAAAsW,EAAAxU,GAxGAL,OAAAW,eAAAxC,EAAA,cAAAyC,OAAA,GACA,IAAAmH,GAAAlI,EAAA,mBASAwW,EAAA,WACA,QAAAA,GAAAC,OACA,KAAAA,IAAAA,GAAA,GACA3X,KAAAyT,QAAA,KACAzT,KAAAyN,KAAA,KACAzN,KAAA2X,UAAAA,EACA3X,KAAA8T,YAAA,KACA9T,KAAAyO,KAAA,KAuBA,MAfAiJ,GAAA5V,UAAAsP,MAAA,SAAA0E,GACA9V,KAAAyT,QAAAqC,EACA9V,KAAAyN,KAAAqI,EAAArI,KACAzN,KAAAyN,MAAAzN,KAAAyN,KAAA4H,MAAA,EAEArV,KAAA8T,YAAA9T,KAAA2X,QAAAN,EAAAD,EAEAtB,EAAAC,UACA/V,KAAA8T,YAAA9T,KAAA2X,QAAAF,EAAAD,EAGAxX,KAAA8T,YAAA9T,KAAA2X,QAAAJ,EAAAD,EAEAtX,KAAAyO,KAAAzO,KAAAyT,QAAAhF,MAEAiJ,IAEAlY,GAAA+E,QAAAmT,6CC3CA,YACArW,QAAAW,eAAAxC,EAAA,cAAAyC,OAAA,GACA,IAAAmH,GAAAlI,EAAA,mBAUA0W,EAAA,WACA,QAAAA,GAAA3V,EAAAoT,EAAA5G,GACAzO,KAAAiC,MAAA,gBAAAA,GAAAmH,EAAA7E,QAAAwQ,SAAA9S,GAAAA,EACAjC,KAAAqV,KAAAA,EACArV,KAAAyN,KAAA,KACAzN,KAAA+V,WAAA,EAEA/V,KAAAyO,KADAA,EACA,kBAAAA,GAAAA,EAAArF,EAAA7E,QAAAmK,aAAAD,GAGA,KAuCA,MAxBAmJ,GAAA9J,WAAA,SAAAjK,GACA,GAAArC,MAAAkM,QAAA7J,EAAA+R,MAAA,CACA,GAAAiC,GAAAhU,EAAA+R,KACAkC,MAAA,GAAAhC,MAAA,EAGA,IAFAA,EAAAgC,EAAA,GAAAF,GAAAC,EAAA,GAAA5V,MAAA4V,EAAA,GAAAxC,KAAAxR,EAAA4K,MAEAoJ,EAAA7W,OAAA,GAAA,IAAA6W,EAAA7W,QAAA6W,EAAA,GAAA5V,QAAA4V,EAAA,GAAA5V,MACA,IAAA,GAAA1B,GAAA,EAAAA,EAAAsX,EAAA7W,SAAAT,EACAuX,EAAArK,KAAA,GAAAmK,GAAAC,EAAAtX,GAAA0B,MAAA4V,EAAAtX,GAAA8U,MACAyC,EAAAA,EAAArK,IAIA,OADAqI,GAAAC,YAAAlS,EAAAkS,UACAD,EAIA,GAAAiC,GAAA,GAAAH,GAAA/T,EAAAkU,MAAA,EAIA,OAFAlU,GAAAmU,MAAAnU,EAAAkU,QACAA,EAAAtK,KAAA,GAAAmK,GAAA/T,EAAAmU,IAAA,IACAD,GAGAH,IAEApY,GAAA+E,QAAAqT,6CC/DA,YACAvW,QAAAW,eAAAxC,EAAA,cAAAyC,OAAA,GACA,IAAAgW,GAAA/W,EAAA,qBACA1B,GAAA+U,cAAA0D,EAAA1T,OACA,IAAA2T,GAAAhX,EAAA,gBACA1B,GAAAoT,SAAAsF,EAAA3T,OACA,IAAA4T,GAAAjX,EAAA,eACA1B,GAAAkK,QAAAyO,EAAA5T,OACA,IAAA6T,GAAAlX,EAAA,oBACA1B,GAAAsX,aAAAsB,EAAA7T,OACA,IAAA8T,GAAAnX,EAAA,wBACA1B,GAAA6C,iBAAAgW,EAAA9T,OACA,IAAA+T,GAAApX,EAAA,kBACA1B,GAAAgF,WAAA8T,EAAA/T,8JCbA,YAGA,IAFAlD,OAAAW,eAAAxC,EAAA,cAAAyC,OAAA,IAEA,mBAAAG,MACA,KAAA,oDAGAA,MAAAmW,YACAnW,KAAAmW,aAGA,IAAAA,GAAArX,EAAA,cAEA,KAAA,GAAAsX,KAAAD,GACAnW,KAAAmW,UAAAC,GAAAD,EAAAC,OAEA,KAAA/Y,GAAAA,EAAAD,UACAC,EAAAD,QAAA+Y","file":"pixi-particles.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Particle_1 = require(\"./Particle\");\nvar Texture = PIXI.Texture;\n/**\n * An individual particle image with an animation. Art data passed to the emitter must be\n * formatted in a particular way for AnimatedParticle to be able to handle it:\n *\n *     {\n *         //framerate is required. It is the animation speed of the particle in frames per\n *         //second.\n *         //A value of \"matchLife\" causes the animation to match the lifetime of an individual\n *         //particle, instead of at a constant framerate. This causes the animation to play\n *         //through one time, completing when the particle expires.\n *         framerate: 6,\n *         //loop is optional, and defaults to false.\n *         loop: true,\n *         //textures is required, and can be an array of any (non-zero) length.\n *         textures: [\n *             //each entry represents a single texture that should be used for one or more\n *             //frames. Any strings will be converted to Textures with Texture.fromImage().\n *             //Instances of PIXI.Texture will be used directly.\n *             \"animFrame1.png\",\n *             //entries can be an object with a 'count' property, telling AnimatedParticle to\n *             //use that texture for 'count' frames sequentially.\n *             {\n *                 texture: \"animFrame2.png\",\n *                 count: 3\n *             },\n *             \"animFrame3.png\"\n *         ]\n *     }\n *\n * @memberof PIXI.particles\n * @class AnimatedParticle\n * @extends PIXI.particles.Particle\n * @constructor\n * @param {PIXI.particles.Emitter} emitter The emitter that controls this AnimatedParticle.\n */\nvar AnimatedParticle = /** @class */ (function (_super) {\n    __extends(AnimatedParticle, _super);\n    function AnimatedParticle(emitter) {\n        var _this = _super.call(this, emitter) || this;\n        _this.textures = null;\n        _this.duration = 0;\n        _this.framerate = 0;\n        _this.elapsed = 0;\n        _this.loop = false;\n        return _this;\n    }\n    /**\n     * Initializes the particle for use, based on the properties that have to\n     * have been set already on the particle.\n     * @method PIXI.particles.AnimatedParticle#init\n     */\n    AnimatedParticle.prototype.init = function () {\n        this.Particle_init();\n        this.elapsed = 0;\n        //if the animation needs to match the particle's life, then cacluate variables\n        if (this.framerate < 0) {\n            this.duration = this.maxLife;\n            this.framerate = this.textures.length / this.duration;\n        }\n    };\n    /**\n     * Sets the textures for the particle.\n     * @method PIXI.particles.AnimatedParticle#applyArt\n     * @param {Array} art An array of PIXI.Texture objects for this animated particle.\n     */\n    AnimatedParticle.prototype.applyArt = function (art) {\n        this.textures = art.textures;\n        this.framerate = art.framerate;\n        this.duration = art.duration;\n        this.loop = art.loop;\n    };\n    /**\n     * Updates the particle.\n     * @method PIXI.particles.AnimatedParticle#update\n     * @param {Number} delta Time elapsed since the previous frame, in __seconds__.\n     */\n    AnimatedParticle.prototype.update = function (delta) {\n        var lerp = this.Particle_update(delta);\n        //only animate the particle if it is still alive\n        if (lerp >= 0) {\n            this.elapsed += delta;\n            if (this.elapsed > this.duration) {\n                //loop elapsed back around\n                if (this.loop)\n                    this.elapsed = this.elapsed % this.duration;\n                //subtract a small amount to prevent attempting to go past the end of the animation\n                else\n                    this.elapsed = this.duration - 0.000001;\n            }\n            var frame = (this.elapsed * this.framerate + 0.0000001) | 0;\n            this.texture = this.textures[frame] || PIXI.Texture.EMPTY;\n        }\n        return lerp;\n    };\n    /**\n     * Destroys the particle, removing references and preventing future use.\n     * @method PIXI.particles.AnimatedParticle#destroy\n     */\n    AnimatedParticle.prototype.destroy = function () {\n        this.Particle_destroy();\n        this.textures = null;\n    };\n    /**\n     * Checks over the art that was passed to the Emitter's init() function, to do any special\n     * modifications to prepare it ahead of time.\n     * @method PIXI.particles.AnimatedParticle.parseArt\n     * @static\n     * @param  {Array} art The array of art data, properly formatted for AnimatedParticle.\n     * @return {Array} The art, after any needed modifications.\n     */\n    AnimatedParticle.parseArt = function (art) {\n        var data, output, textures, tex, outTextures;\n        var outArr = [];\n        for (var i = 0; i < art.length; ++i) {\n            data = art[i];\n            outArr[i] = output = {};\n            output.textures = outTextures = [];\n            textures = data.textures;\n            for (var j = 0; j < textures.length; ++j) {\n                tex = textures[j];\n                if (typeof tex == \"string\")\n                    outTextures.push(Texture.fromImage(tex));\n                else if (tex instanceof Texture)\n                    outTextures.push(tex);\n                //assume an object with extra data determining duplicate frame data\n                else {\n                    var dupe = tex.count || 1;\n                    if (typeof tex.texture == \"string\")\n                        tex = Texture.fromImage(tex.texture);\n                    else // if(tex.texture instanceof Texture)\n                        tex = tex.texture;\n                    for (; dupe > 0; --dupe) {\n                        outTextures.push(tex);\n                    }\n                }\n            }\n            //use these values to signify that the animation should match the particle life time.\n            if (data.framerate == \"matchLife\") {\n                //-1 means that it should be calculated\n                output.framerate = -1;\n                output.duration = 0;\n                output.loop = false;\n            }\n            else {\n                //determine if the animation should loop\n                output.loop = !!data.loop;\n                //get the framerate, default to 60\n                output.framerate = data.framerate > 0 ? data.framerate : 60;\n                //determine the duration\n                output.duration = outTextures.length / output.framerate;\n            }\n        }\n        return outArr;\n    };\n    return AnimatedParticle;\n}(Particle_1.default));\nexports.default = AnimatedParticle;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A Catmull-Rom spline\n * @memberof PIXI.particles\n * @constructor\n */\nvar CatmullRom = /** @class */ (function () {\n    /**\n     * @function CatmullRom\n     * @Description helper function for creating/storing a set of points defining a smooth path\n     * @param controlPoints {Array<PIXI.Point>}\n     * @param [kAlpha = 0.5] {number} knot parameterisation. 0 = uniform/tight, 0.5 = centripetal/default, 1.0 = chordal/loose.\n     * @param [pointsPerSegment = 50] {number} Total points generated across any two control points.\n     * @constructor\n     */\n    function CatmullRom(controlPoints, kAlpha, pointsPerSegment) {\n        this._controlPoints = controlPoints;\n        this._kAlpha = (kAlpha == 0 ? 0 : (kAlpha || 0.5));\n        this._pointsPerSegment = pointsPerSegment || 50;\n        this._points = [];\n        this._dirty = true;\n    }\n    /**\n     * Merges two arrays, removing any duplicate values\n     * @method PIXI.particles.CatmullRom#mergeUnique\n     */\n    CatmullRom.mergeUnique = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var hash = {}, ret = [], encode, i, j;\n        for (i = 0; i < args.length; i++) {\n            for (j = 0; j < args[i].length; j++) {\n                encode = args[i][j].x + \"_\" + args[i][j].y;\n                if (hash[encode] !== true) {\n                    hash[encode] = true;\n                    ret[ret.length] = args[i][j];\n                }\n            }\n        }\n        return ret;\n    };\n    /**\n     * Calculates the distance between two points.\n     * @method PIXI.particles.CatmullRom#pointDistance\n     */\n    CatmullRom.pointDistance = function (a, b) {\n        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n    };\n    /**\n     * Calculates the angle between two points.\n     * @method PIXI.particles.CatmullRom#pointAngle\n     */\n    CatmullRom.pointAngle = function (a, b) {\n        return Math.atan2(b.x - a.x, b.y - a.y);\n    };\n    /**\n     * returns the point nearest to the input point\n     * @method getNearest\n     * @param point {PIXI.Point} Point to test\n     * @returns {PIXI.Point}\n     */\n    CatmullRom.prototype.getNearest = function (point) {\n        var nearest = 0;\n        var dist = CatmullRom.pointDistance(point, this._points[0]);\n        var newDist;\n        for (var i = 0; i < this._points.length; i++) {\n            if (this._points[i].x === point.x && this._points[i].y === point.y) {\n                return this._points[i];\n            }\n            else {\n                newDist = CatmullRom.pointDistance(point, this._points[i]);\n                if (dist > newDist) {\n                    nearest = i;\n                    dist = newDist;\n                }\n            }\n        }\n        return this._points[nearest];\n    };\n    ;\n    /**\n     * @method getIndex\n     * @description returns the point index at the given progress\n     * @param progress {number} Path progress as a fraction\n     */\n    CatmullRom.prototype.getIndex = function (progress) {\n        var index = (this._points.length) * (progress % 1);\n        if (index < 0) {\n            index = this._points.length + index;\n        }\n        return Math.floor(index);\n    };\n    ;\n    /**\n     * @method getNormals\n     * @description returns the normal vector at the input point (i.e. away from the middle of the shape)\n     * @param index {number} Input point index\n     */\n    CatmullRom.prototype.getNormals = function (index) {\n        var pointPrev = this._points[index === 0 ? this._points.length - 1 : index - 1];\n        var pointNext = this._points[index === this._points.length - 1 ? 0 : index + 1];\n        var len = CatmullRom.pointDistance(pointPrev, pointNext);\n        var dx = (pointNext.x - pointPrev.x) / len;\n        var dy = (pointNext.y - pointPrev.y) / len;\n        return { toward: new PIXI.Point(-dy, dx), away: new PIXI.Point(dy, -dx) };\n    };\n    ;\n    Object.defineProperty(CatmullRom.prototype, \"controlPoints\", {\n        /**\n         * @member {Array} PIXI.particles.CatmullRom#controlPoints\n         */\n        get: function () {\n            if (this._dirty) {\n                this.populate();\n            }\n            return this._controlPoints;\n        },\n        set: function (newVal) {\n            this._controlPoints = newVal;\n            this._dirty = true;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ;\n    ;\n    Object.defineProperty(CatmullRom.prototype, \"kAlpha\", {\n        /**\n         * @member {number} PIXI.particles.CatmullRom#kAlpha\n         */\n        get: function () {\n            if (this._dirty) {\n                this.populate();\n            }\n            return this._kAlpha;\n        },\n        set: function (newVal) {\n            if (this._kAlpha !== newVal) {\n                this._kAlpha = newVal;\n                this._dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ;\n    ;\n    Object.defineProperty(CatmullRom.prototype, \"pointsPerSegment\", {\n        /**\n         * @member {number} PIXI.particles.CatmullRom#pointsPerSegment\n         */\n        get: function () {\n            if (this._dirty) {\n                this.populate();\n            }\n            return this._pointsPerSegment;\n        },\n        set: function (newVal) {\n            if (this._pointsPerSegment !== newVal) {\n                this._pointsPerSegment = newVal;\n                this._dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ;\n    ;\n    Object.defineProperty(CatmullRom.prototype, \"points\", {\n        /**\n         * @member {Array} PIXI.particles.CatmullRom#points\n         */\n        get: function () {\n            if (this._dirty) {\n                this.populate();\n            }\n            return this._points;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ;\n    /**\n     * updates the spline points\n     * @method PIXI.particles.CatmullRom#populate\n     */\n    CatmullRom.prototype.populate = function () {\n        var last = this._controlPoints.length - 1;\n        this._points = this.catmullRomSpline(this._controlPoints[last], this._controlPoints[0], this._controlPoints[1], this._controlPoints[2]);\n        for (var i = 1; i < last - 1; i++) {\n            this._points = CatmullRom.mergeUnique(this._points, this.catmullRomSpline(this._controlPoints[i - 1], this._controlPoints[i], this._controlPoints[i + 1], this._controlPoints[i + 2]));\n        }\n        this._points = CatmullRom.mergeUnique(this._points, this.catmullRomSpline(this._controlPoints[last - 2], this._controlPoints[last - 1], this._controlPoints[last], this._controlPoints[0]), this.catmullRomSpline(this._controlPoints[last - 1], this._controlPoints[last], this._controlPoints[0], this._controlPoints[1]));\n        this._dirty = false;\n    };\n    /**\n     * @method PIXI.particles.CatmullRom#catmullRomSpline\n     * @description Generates a series of points defining a curve between points P1 and P2.\n     * @param P0 {PIXI.Point} previous point in series\n     * @param P1 {PIXI.Point} first point in spline\n     * @param P2 {PIXI.Point} end point in spline\n     * @param P3 {PIXI.Point} next point in series\n     */\n    CatmullRom.prototype.catmullRomSpline = function (P0, P1, P2, P3) {\n        //Calculate knots\n        var t0, t1, t2, t3;\n        function tNext(tPrev, pPrev, pNext, kAlpha) {\n            return Math.pow(Math.sqrt(Math.pow(pNext.x - pPrev.x, 2) + Math.pow(pNext.y - pPrev.y, 2)), kAlpha) + tPrev;\n        }\n        t0 = 0;\n        t1 = tNext(t0, P0, P1, this._kAlpha);\n        t2 = tNext(t1, P1, P2, this._kAlpha);\n        t3 = tNext(t2, P2, P3, this._kAlpha);\n        //get intervals between knots\n        function linSpace(t1, t2, numKnots) {\n            var ret = [t1];\n            var dist = (t2 - t1) / (numKnots - 1);\n            while (ret.length < numKnots - 1) {\n                ret[ret.length] = ret[ret.length - 1] + dist;\n            }\n            ret[ret.length] = t2;\n            return ret;\n        }\n        /**\n         * @function AN\n         * @description calculates the \"A\" spline equations\n         * @param t {number} Position on the spline between t1 and t2\n         * @param tP {number} Previous knot\n         * @param tN {number} Next knot\n         * @param PP {PIXI.Point} Previous control point\n         * @param PN {PIXI.Point} Next control point\n         */\n        function AN(t, tP, tN, PP, PN) {\n            var x = ((tN - t) / (tN - tP) * PP.x) + ((t - tP) / (tN - tP) * PN.x);\n            var y = ((tN - t) / (tN - tP) * PP.y) + ((t - tP) / (tN - tP) * PN.y);\n            return new PIXI.Point(x, y);\n        }\n        /**\n         * @function BN\n         * @description calculates the \"B\" spline equations\n         * @param t {number} Position on the spline between t1 and t2\n         * @param tP {number} Previous knot\n         * @param tN {number} Next knot\n         * @param AP {PIXI.Point} result of AN(t, t(N-1), t(N))\n         * @param AN {PIXI.Point} result of AN(t, t(N), t(N+1))\n         */\n        function BN(t, tP, tN, AP, AN) {\n            var x = ((tN - t) / (tN - tP) * AP.x) + ((t - tP) / (tN - tP) * AN.x);\n            var y = ((tN - t) / (tN - tP) * AP.y) + ((t - tP) / (tN - tP) * AN.y);\n            return new PIXI.Point(x, y);\n        }\n        /**\n         * @function C\n         * @description calculates the \"C\" spline equation (C  = (t2-t)/(t2-t1)*B1 + (t-t1)/(t2-t1)*B2)\n         * @param t {number} Position on the spline between t1 and t2\n         */\n        function C(t) {\n            var A1 = AN(t, t0, t1, P0, P1);\n            var A2 = AN(t, t1, t2, P1, P2);\n            var A3 = AN(t, t2, t3, P2, P3);\n            var B1 = BN(t, t0, t2, A1, A2);\n            var B2 = BN(t, t1, t3, A2, A3);\n            var x = (((t2 - t) / (t2 - t1)) * B1.x) + ((t - t1) / (t2 - t1) * B2.x);\n            var y = (((t2 - t) / (t2 - t1)) * B1.y) + ((t - t1) / (t2 - t1) * B2.y);\n            return new PIXI.Point(x, y);\n        }\n        var segments = linSpace(t1, t2, this._pointsPerSegment);\n        var ret = [];\n        for (var i = 0; i < segments.length; i++) {\n            ret[i] = C(segments[i]);\n        }\n        return ret;\n    };\n    return CatmullRom;\n}());\nexports.default = CatmullRom;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ParticleUtils_1 = require(\"./ParticleUtils\");\nvar Particle_1 = require(\"./Particle\");\nvar PropertyNode_1 = require(\"./PropertyNode\");\nvar ticker = PIXI.ticker.shared;\nvar CatmullRom_1 = require(\"./CatmullRom\");\nvar helperPoint = new PIXI.Point();\n/**\n * A particle emitter.\n * @memberof PIXI.particles\n * @class Emitter\n * @constructor\n * @param {PIXI.Container} particleParent The container to add the\n *                                                     particles to.\n * @param {Array|PIXI.Texture|String} [particleImages] A texture or array of textures to use\n *                                                     for the particles. Strings will be turned\n *                                                     into textures via Texture.fromImage().\n * @param {Object} [config] A configuration object containing settings for the emitter.\n * @param {Boolean} [config.emit=true] If config.emit is explicitly passed as false, the Emitter\n *                                     will start disabled.\n * @param {Boolean} [config.autoUpdate=false] If config.emit is explicitly passed as true, the Emitter\n *                                     will automatically call update via the PIXI shared ticker.\n */\nvar Emitter = /** @class */ (function () {\n    function Emitter(particleParent, particleImages, config) {\n        this._particleConstructor = Particle_1.default;\n        //properties for individual particles\n        this.particleImages = null;\n        this.startAlpha = null;\n        this.startSpeed = null;\n        this.minimumSpeedMultiplier = 1;\n        this.acceleration = null;\n        this.maxSpeed = NaN;\n        this.startScale = null;\n        this.minimumScaleMultiplier = 1;\n        this.startColor = null;\n        this.minLifetime = 0;\n        this.maxLifetime = 0;\n        this.minStartRotation = 0;\n        this.maxStartRotation = 0;\n        this.noRotation = false;\n        this.minRotationSpeed = 0;\n        this.maxRotationSpeed = 0;\n        this.particleBlendMode = 0;\n        this.customEase = null;\n        this.extraData = null;\n        //properties for spawning particles\n        this._frequency = 1;\n        this.spawnChance = 1;\n        this.maxParticles = 1000;\n        this.emitterLifetime = -1;\n        this.spawnPos = null;\n        this.spawnType = null;\n        this._spawnFunc = null;\n        this.spawnRect = null;\n        this.spawnCircle = null;\n        this.spawnSpline = null;\n        this.particlesPerWave = 1;\n        this.particleSpacing = 0;\n        this.angleStart = 0;\n        //emitter properties\n        this.rotation = 0;\n        this.ownerPos = null;\n        this._prevEmitterPos = null;\n        this._prevPosIsValid = false;\n        this._posChanged = false;\n        this._parent = null;\n        this.addAtBack = false;\n        this.particleCount = 0;\n        this._emit = false;\n        this._spawnTimer = 0;\n        this._emitterLife = -1;\n        this._activeParticlesFirst = null;\n        this._activeParticlesLast = null;\n        this._poolFirst = null;\n        this._origConfig = null;\n        this._origArt = null;\n        this._autoUpdate = false;\n        this._destroyWhenComplete = false;\n        this._completeCallback = null;\n        //set the initial parent\n        this.parent = particleParent;\n        if (particleImages && config)\n            this.init(particleImages, config);\n        //save often used functions on the instance instead of the prototype for better speed\n        this.recycle = this.recycle;\n        this.update = this.update;\n        this.rotate = this.rotate;\n        this.updateSpawnPos = this.updateSpawnPos;\n        this.updateOwnerPos = this.updateOwnerPos;\n    }\n    Object.defineProperty(Emitter.prototype, \"frequency\", {\n        /**\n         * Time between particle spawns in seconds. If this value is not a number greater than 0,\n         * it will be set to 1 (particle per second) to prevent infinite loops.\n         * @member {Number} PIXI.particles.Emitter#frequency\n         */\n        get: function () { return this._frequency; },\n        set: function (value) {\n            //do some error checking to prevent infinite loops\n            if (typeof value == \"number\" && value > 0)\n                this._frequency = value;\n            else\n                this._frequency = 1;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Emitter.prototype, \"particleConstructor\", {\n        /**\n         * The constructor used to create new particles. The default is\n         * the built in Particle class. Setting this will dump any active or\n         * pooled particles, if the emitter has already been used.\n         * @member {Function} PIXI.particles.Emitter#particleConstructor\n         */\n        get: function () { return this._particleConstructor; },\n        set: function (value) {\n            if (value != this._particleConstructor) {\n                this._particleConstructor = value;\n                //clean up existing particles\n                this.cleanup();\n                //scrap all the particles\n                for (var particle = this._poolFirst; particle; particle = particle.next) {\n                    particle.destroy();\n                }\n                this._poolFirst = null;\n                //re-initialize the emitter so that the new constructor can do anything it needs to\n                if (this._origConfig && this._origArt)\n                    this.init(this._origArt, this._origConfig);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Emitter.prototype, \"parent\", {\n        /**\n        * The container to add particles to. Settings this will dump any active particles.\n        * @member {PIXI.Container} PIXI.particles.Emitter#parent\n        */\n        get: function () { return this._parent; },\n        set: function (value) {\n            this.cleanup();\n            this._parent = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Sets up the emitter based on the config settings.\n     * @method PIXI.particles.Emitter#init\n     * @param {Array|PIXI.Texture} art A texture or array of textures to use for the particles.\n     * @param {Object} config A configuration object containing settings for the emitter.\n     */\n    Emitter.prototype.init = function (art, config) {\n        if (!art || !config)\n            return;\n        //clean up any existing particles\n        this.cleanup();\n        //store the original config and particle images, in case we need to re-initialize\n        //when the particle constructor is changed\n        this._origConfig = config;\n        this._origArt = art;\n        //set up the array of data, also ensuring that it is an array\n        art = Array.isArray(art) ? art.slice() : [art];\n        //run the art through the particle class's parsing function\n        var partClass = this._particleConstructor;\n        this.particleImages = partClass.parseArt ? partClass.parseArt(art) : art;\n        ///////////////////////////\n        // Particle Properties   //\n        ///////////////////////////\n        //set up the alpha\n        if (config.alpha) {\n            this.startAlpha = PropertyNode_1.default.createList(config.alpha);\n        }\n        else\n            this.startAlpha = new PropertyNode_1.default(1, 0);\n        //set up the speed\n        if (config.speed) {\n            this.startSpeed = PropertyNode_1.default.createList(config.speed);\n            this.minimumSpeedMultiplier = config.speed.minimumSpeedMultiplier || 1;\n        }\n        else {\n            this.minimumSpeedMultiplier = 1;\n            this.startSpeed = new PropertyNode_1.default(0, 0);\n        }\n        //set up acceleration\n        var acceleration = config.acceleration;\n        if (acceleration && (acceleration.x || acceleration.y)) {\n            //make sure we disable speed interpolation\n            this.startSpeed.next = null;\n            this.acceleration = new PIXI.Point(acceleration.x, acceleration.y);\n            this.maxSpeed = config.maxSpeed || NaN;\n        }\n        else\n            this.acceleration = new PIXI.Point();\n        //set up the scale\n        if (config.scale) {\n            this.startScale = PropertyNode_1.default.createList(config.scale);\n            this.minimumScaleMultiplier = config.scale.minimumScaleMultiplier || 1;\n        }\n        else {\n            this.startScale = new PropertyNode_1.default(1, 0);\n            this.minimumScaleMultiplier = 1;\n        }\n        //set up the color\n        if (config.color) {\n            this.startColor = PropertyNode_1.default.createList(config.color);\n        }\n        else {\n            this.startColor = new PropertyNode_1.default({ r: 0xFF, g: 0xFF, b: 0xFF }, 0);\n        }\n        //set up the start rotation\n        if (config.startRotation) {\n            this.minStartRotation = config.startRotation.min;\n            this.maxStartRotation = config.startRotation.max;\n        }\n        else\n            this.minStartRotation = this.maxStartRotation = 0;\n        if (config.noRotation &&\n            (this.minStartRotation || this.maxStartRotation)) {\n            this.noRotation = !!config.noRotation;\n        }\n        else\n            this.noRotation = false;\n        //set up the rotation speed\n        if (config.rotationSpeed) {\n            this.minRotationSpeed = config.rotationSpeed.min;\n            this.maxRotationSpeed = config.rotationSpeed.max;\n        }\n        else\n            this.minRotationSpeed = this.maxRotationSpeed = 0;\n        //set up the lifetime\n        this.minLifetime = config.lifetime.min;\n        this.maxLifetime = config.lifetime.max;\n        //get the blend mode\n        this.particleBlendMode = ParticleUtils_1.default.getBlendMode(config.blendMode);\n        //use the custom ease if provided\n        if (config.ease) {\n            this.customEase = typeof config.ease == \"function\" ?\n                config.ease :\n                ParticleUtils_1.default.generateEase(config.ease);\n        }\n        else\n            this.customEase = null;\n        //set up the extra data, running it through the particle class's parseData function.\n        if (partClass.parseData)\n            this.extraData = partClass.parseData(config.extraData);\n        else\n            this.extraData = config.extraData || null;\n        //////////////////////////\n        // Emitter Properties   //\n        //////////////////////////\n        //reset spawn type specific settings\n        this.spawnRect = this.spawnCircle = this.spawnSpline = null;\n        this.particlesPerWave = 1;\n        if (config.particlesPerWave && config.particlesPerWave > 1)\n            this.particlesPerWave = config.particlesPerWave;\n        this.particleSpacing = 0;\n        this.angleStart = 0;\n        var spawnCircle;\n        var spawnSpline;\n        //determine the spawn function to use\n        switch (config.spawnType) {\n            case \"rect\":\n                this.spawnType = \"rect\";\n                this._spawnFunc = this._spawnRect;\n                var spawnRect = config.spawnRect;\n                this.spawnRect = new PIXI.Rectangle(spawnRect.x, spawnRect.y, spawnRect.w, spawnRect.h);\n                break;\n            case \"circle\":\n                this.spawnType = \"circle\";\n                this._spawnFunc = this._spawnCircle;\n                spawnCircle = config.spawnCircle;\n                this.spawnCircle = new PIXI.Circle(spawnCircle.x, spawnCircle.y, spawnCircle.r);\n                break;\n            case \"ring\":\n                this.spawnType = \"ring\";\n                this._spawnFunc = this._spawnRing;\n                spawnCircle = config.spawnCircle;\n                this.spawnCircle = new PIXI.Circle(spawnCircle.x, spawnCircle.y, spawnCircle.r);\n                this.spawnCircle.minRadius = spawnCircle.minR;\n                break;\n            case \"burst\":\n                this.spawnType = \"burst\";\n                this._spawnFunc = this._spawnBurst;\n                this.particleSpacing = config.particleSpacing;\n                this.angleStart = config.angleStart ? config.angleStart : 0;\n                break;\n            case \"spline\":\n                this.spawnType = \"spline\";\n                this._spawnFunc = this._spawnSpline;\n                spawnSpline = config.spawnSpline;\n                this.spawnSpline = new CatmullRom_1.default(spawnSpline.controlPoints, spawnSpline.kAlpha, spawnSpline.pointsPerSegment);\n                break;\n            case \"point\":\n                this.spawnType = \"point\";\n                this._spawnFunc = this._spawnPoint;\n                break;\n            default:\n                this.spawnType = \"point\";\n                this._spawnFunc = this._spawnPoint;\n                break;\n        }\n        //set the spawning frequency\n        this.frequency = config.frequency;\n        this.spawnChance = (typeof config.spawnChance === 'number' && config.spawnChance > 0) ? config.spawnChance : 1;\n        //set the emitter lifetime\n        this.emitterLifetime = config.emitterLifetime || -1;\n        //set the max particles\n        this.maxParticles = config.maxParticles > 0 ? config.maxParticles : 1000;\n        //determine if we should add the particle at the back of the list or not\n        this.addAtBack = !!config.addAtBack;\n        //reset the emitter position and rotation variables\n        this.rotation = 0;\n        this.ownerPos = new PIXI.Point();\n        this.spawnPos = new PIXI.Point(config.pos.x, config.pos.y);\n        this._prevEmitterPos = this.spawnPos.clone();\n        //previous emitter position is invalid and should not be used for interpolation\n        this._prevPosIsValid = false;\n        //start emitting\n        this._spawnTimer = 0;\n        this.emit = config.emit === undefined ? true : !!config.emit;\n        this.autoUpdate = config.autoUpdate === undefined ? false : !!config.autoUpdate;\n    };\n    /**\n     * Recycles an individual particle.\n     * @method PIXI.particles.Emitter#recycle\n     * @param {Particle} particle The particle to recycle.\n     * @private\n     */\n    Emitter.prototype.recycle = function (particle) {\n        if (particle.next)\n            particle.next.prev = particle.prev;\n        if (particle.prev)\n            particle.prev.next = particle.next;\n        if (particle == this._activeParticlesLast)\n            this._activeParticlesLast = particle.prev;\n        if (particle == this._activeParticlesFirst)\n            this._activeParticlesFirst = particle.next;\n        //add to pool\n        particle.prev = null;\n        particle.next = this._poolFirst;\n        this._poolFirst = particle;\n        //remove child from display, or make it invisible if it is in a ParticleContainer\n        if (particle.parent)\n            particle.parent.removeChild(particle);\n        //decrease count\n        --this.particleCount;\n    };\n    /**\n     * Sets the rotation of the emitter to a new value.\n     * @method PIXI.particles.Emitter#rotate\n     * @param {Number} newRot The new rotation, in degrees.\n     */\n    Emitter.prototype.rotate = function (newRot) {\n        if (this.rotation == newRot)\n            return;\n        //caclulate the difference in rotation for rotating spawnPos\n        var diff = newRot - this.rotation;\n        this.rotation = newRot;\n        //rotate spawnPos\n        ParticleUtils_1.default.rotatePoint(diff, this.spawnPos);\n        //mark the position as having changed\n        this._posChanged = true;\n    };\n    /**\n     * Changes the spawn position of the emitter.\n     * @method PIXI.particles.Emitter#updateSpawnPos\n     * @param {Number} x The new x value of the spawn position for the emitter.\n     * @param {Number} y The new y value of the spawn position for the emitter.\n     */\n    Emitter.prototype.updateSpawnPos = function (x, y) {\n        this._posChanged = true;\n        this.spawnPos.x = x;\n        this.spawnPos.y = y;\n    };\n    /**\n     * Changes the position of the emitter's owner. You should call this if you are adding\n     * particles to the world container that your emitter's owner is moving around in.\n     * @method PIXI.particles.Emitter#updateOwnerPos\n     * @param {Number} x The new x value of the emitter's owner.\n     * @param {Number} y The new y value of the emitter's owner.\n     */\n    Emitter.prototype.updateOwnerPos = function (x, y) {\n        this._posChanged = true;\n        this.ownerPos.x = x;\n        this.ownerPos.y = y;\n    };\n    /**\n     * Prevents emitter position interpolation in the next update.\n     * This should be used if you made a major position change of your emitter's owner\n     * that was not normal movement.\n     * @method PIXI.particles.Emitter#resetPositionTracking\n     */\n    Emitter.prototype.resetPositionTracking = function () {\n        this._prevPosIsValid = false;\n    };\n    Object.defineProperty(Emitter.prototype, \"emit\", {\n        /**\n         * If particles should be emitted during update() calls. Setting this to false\n         * stops new particles from being created, but allows existing ones to die out.\n         * @member {Boolean} PIXI.particles.Emitter#emit\n         */\n        get: function () { return this._emit; },\n        set: function (value) {\n            this._emit = !!value;\n            this._emitterLife = this.emitterLifetime;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ;\n    Object.defineProperty(Emitter.prototype, \"autoUpdate\", {\n        /**\n         * If the update function is called automatically from the shared ticker.\n         * Setting this to false requires calling the update function manually.\n         * @member {Boolean} PIXI.particles.Emitter#autoUpdate\n         */\n        get: function () { return this._autoUpdate; },\n        set: function (value) {\n            if (this._autoUpdate && !value) {\n                ticker.remove(this.update, this);\n            }\n            else if (!this._autoUpdate && value) {\n                ticker.add(this.update, this);\n            }\n            this._autoUpdate = !!value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Starts emitting particles, sets autoUpdate to true, and sets up the Emitter to destroy itself\n     * when particle emission is complete.\n     * @method PIXI.particles.Emitter#playOnceAndDestroy\n     * @param {Function} [callback] Callback for when emission is complete (all particles have died off)\n     */\n    Emitter.prototype.playOnceAndDestroy = function (callback) {\n        this.autoUpdate = true;\n        this.emit = true;\n        this._destroyWhenComplete = true;\n        this._completeCallback = callback;\n    };\n    /**\n     * Starts emitting particles and optionally calls a callback when particle emission is complete.\n     * @method PIXI.particles.Emitter#playOnce\n     * @param {Function} [callback] Callback for when emission is complete (all particles have died off)\n     */\n    Emitter.prototype.playOnce = function (callback) {\n        this.emit = true;\n        this._completeCallback = callback;\n    };\n    /**\n     * Updates all particles spawned by this emitter and emits new ones.\n     * @method PIXI.particles.Emitter#update\n     * @param {Number} delta Time elapsed since the previous frame, in __seconds__.\n     */\n    Emitter.prototype.update = function (delta) {\n        if (this._autoUpdate) {\n            delta = delta / PIXI.settings.TARGET_FPMS / 1000;\n        }\n        //if we don't have a parent to add particles to, then don't do anything.\n        //this also works as a isDestroyed check\n        if (!this._parent)\n            return;\n        //update existing particles\n        var i, particle, next;\n        for (particle = this._activeParticlesFirst; particle; particle = next) {\n            next = particle.next;\n            particle.update(delta);\n        }\n        var prevX, prevY;\n        //if the previous position is valid, store these for later interpolation\n        if (this._prevPosIsValid) {\n            prevX = this._prevEmitterPos.x;\n            prevY = this._prevEmitterPos.y;\n        }\n        //store current position of the emitter as local variables\n        var curX = this.ownerPos.x + this.spawnPos.x;\n        var curY = this.ownerPos.y + this.spawnPos.y;\n        //spawn new particles\n        if (this._emit) {\n            //decrease spawn timer\n            this._spawnTimer -= delta < 0 ? 0 : delta;\n            //while _spawnTimer < 0, we have particles to spawn\n            while (this._spawnTimer <= 0) {\n                //determine if the emitter should stop spawning\n                if (this._emitterLife > 0) {\n                    this._emitterLife -= this._frequency;\n                    if (this._emitterLife <= 0) {\n                        this._spawnTimer = 0;\n                        this._emitterLife = 0;\n                        this.emit = false;\n                        break;\n                    }\n                }\n                //determine if we have hit the particle limit\n                if (this.particleCount >= this.maxParticles) {\n                    this._spawnTimer += this._frequency;\n                    continue;\n                }\n                //determine the particle lifetime\n                var lifetime = void 0;\n                if (this.minLifetime == this.maxLifetime)\n                    lifetime = this.minLifetime;\n                else\n                    lifetime = Math.random() * (this.maxLifetime - this.minLifetime) + this.minLifetime;\n                //only make the particle if it wouldn't immediately destroy itself\n                if (-this._spawnTimer < lifetime) {\n                    //If the position has changed and this isn't the first spawn,\n                    //interpolate the spawn position\n                    var emitPosX = void 0, emitPosY = void 0;\n                    if (this._prevPosIsValid && this._posChanged) {\n                        //1 - _spawnTimer / delta, but _spawnTimer is negative\n                        var lerp = 1 + this._spawnTimer / delta;\n                        emitPosX = (curX - prevX) * lerp + prevX;\n                        emitPosY = (curY - prevY) * lerp + prevY;\n                    }\n                    else //otherwise just set to the spawn position\n                     {\n                        emitPosX = curX;\n                        emitPosY = curY;\n                    }\n                    //create enough particles to fill the wave (non-burst types have a wave of 1)\n                    i = 0;\n                    for (var len = Math.min(this.particlesPerWave, this.maxParticles - this.particleCount); i < len; ++i) {\n                        //see if we actually spawn one\n                        if (this.spawnChance < 1 && Math.random() >= this.spawnChance)\n                            continue;\n                        //create particle\n                        var p = void 0;\n                        if (this._poolFirst) {\n                            p = this._poolFirst;\n                            this._poolFirst = this._poolFirst.next;\n                            p.next = null;\n                        }\n                        else {\n                            p = new this.particleConstructor(this);\n                        }\n                        //set a random texture if we have more than one\n                        if (this.particleImages.length > 1) {\n                            p.applyArt(this.particleImages[Math.floor(Math.random() * this.particleImages.length)]);\n                        }\n                        else {\n                            //if they are actually the same texture, a standard particle\n                            //will quit early from the texture setting in setTexture().\n                            p.applyArt(this.particleImages[0]);\n                        }\n                        //set up the start and end values\n                        p.alphaList.reset(this.startAlpha);\n                        if (this.minimumSpeedMultiplier != 1) {\n                            p.speedMultiplier = Math.random() * (1 - this.minimumSpeedMultiplier) + this.minimumSpeedMultiplier;\n                        }\n                        p.speedList.reset(this.startSpeed);\n                        p.acceleration.x = this.acceleration.x;\n                        p.acceleration.y = this.acceleration.y;\n                        p.maxSpeed = this.maxSpeed;\n                        if (this.minimumScaleMultiplier != 1) {\n                            p.scaleMultiplier = Math.random() * (1 - this.minimumScaleMultiplier) + this.minimumScaleMultiplier;\n                        }\n                        p.scaleList.reset(this.startScale);\n                        p.colorList.reset(this.startColor);\n                        //randomize the rotation speed\n                        if (this.minRotationSpeed == this.maxRotationSpeed)\n                            p.rotationSpeed = this.minRotationSpeed;\n                        else\n                            p.rotationSpeed = Math.random() * (this.maxRotationSpeed - this.minRotationSpeed) + this.minRotationSpeed;\n                        p.noRotation = this.noRotation;\n                        //set up the lifetime\n                        p.maxLife = lifetime;\n                        //set the blend mode\n                        p.blendMode = this.particleBlendMode;\n                        //set the custom ease, if any\n                        p.ease = this.customEase;\n                        //set the extra data, if any\n                        p.extraData = this.extraData;\n                        //call the proper function to handle rotation and position of particle\n                        this._spawnFunc(p, emitPosX, emitPosY, i);\n                        //initialize particle\n                        p.init();\n                        //update the particle by the time passed, so the particles are spread out properly\n                        p.update(-this._spawnTimer); //we want a positive delta, because a negative delta messes things up\n                        //add the particle to the display list\n                        if (!p.parent) {\n                            if (this.addAtBack)\n                                this._parent.addChildAt(p, 0);\n                            else\n                                this._parent.addChild(p);\n                        }\n                        else {\n                            //kind of hacky, but performance friendly\n                            //shuffle children to correct place\n                            var children = this._parent.children;\n                            //avoid using splice if possible\n                            if (children[0] == p)\n                                children.shift();\n                            else if (children[children.length - 1] == p)\n                                children.pop();\n                            else {\n                                var index = children.indexOf(p);\n                                children.splice(index, 1);\n                            }\n                            if (this.addAtBack)\n                                children.unshift(p);\n                            else\n                                children.push(p);\n                        }\n                        //add particle to list of active particles\n                        if (this._activeParticlesLast) {\n                            this._activeParticlesLast.next = p;\n                            p.prev = this._activeParticlesLast;\n                            this._activeParticlesLast = p;\n                        }\n                        else {\n                            this._activeParticlesLast = this._activeParticlesFirst = p;\n                        }\n                        ++this.particleCount;\n                    }\n                }\n                //increase timer and continue on to any other particles that need to be created\n                this._spawnTimer += this._frequency;\n            }\n        }\n        //if the position changed before this update, then keep track of that\n        if (this._posChanged) {\n            this._prevEmitterPos.x = curX;\n            this._prevEmitterPos.y = curY;\n            this._prevPosIsValid = true;\n            this._posChanged = false;\n        }\n        //if we are all done and should destroy ourselves, take care of that\n        if (!this._emit && !this._activeParticlesFirst) {\n            if (this._completeCallback) {\n                this._completeCallback();\n            }\n            if (this._destroyWhenComplete) {\n                this.destroy();\n            }\n        }\n    };\n    /**\n     * Positions a particle for a point type emitter.\n     * @method PIXI.particles.Emitter#_spawnPoint\n     * @private\n     * @param {Particle} p The particle to position and rotate.\n     * @param {Number} emitPosX The emitter's x position\n     * @param {Number} emitPosY The emitter's y position\n     * @param {int} i The particle number in the current wave. Not used for this function.\n     */\n    Emitter.prototype._spawnPoint = function (p, emitPosX, emitPosY) {\n        //set the initial rotation/direction of the particle based on\n        //starting particle angle and rotation of emitter\n        if (this.minStartRotation == this.maxStartRotation)\n            p.rotation = this.minStartRotation + this.rotation;\n        else\n            p.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) + this.minStartRotation + this.rotation;\n        //drop the particle at the emitter's position\n        p.position.x = emitPosX;\n        p.position.y = emitPosY;\n    };\n    /**\n     * Positions a particle for a rectangle type emitter.\n     * @method PIXI.particles.Emitter#_spawnRect\n     * @private\n     * @param {Particle} p The particle to position and rotate.\n     * @param {Number} emitPosX The emitter's x position\n     * @param {Number} emitPosY The emitter's y position\n     * @param {int} i The particle number in the current wave. Not used for this function.\n     */\n    Emitter.prototype._spawnRect = function (p, emitPosX, emitPosY) {\n        //set the initial rotation/direction of the particle based on starting\n        //particle angle and rotation of emitter\n        if (this.minStartRotation == this.maxStartRotation)\n            p.rotation = this.minStartRotation + this.rotation;\n        else\n            p.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) + this.minStartRotation + this.rotation;\n        //place the particle at a random point in the rectangle\n        helperPoint.x = Math.random() * this.spawnRect.width + this.spawnRect.x;\n        helperPoint.y = Math.random() * this.spawnRect.height + this.spawnRect.y;\n        if (this.rotation !== 0)\n            ParticleUtils_1.default.rotatePoint(this.rotation, helperPoint);\n        p.position.x = emitPosX + helperPoint.x;\n        p.position.y = emitPosY + helperPoint.y;\n    };\n    /**\n     * Positions a particle for a circle type emitter.\n     * @method PIXI.particles.Emitter#_spawnCircle\n     * @private\n     * @param {Particle} p The particle to position and rotate.\n     * @param {Number} emitPosX The emitter's x position\n     * @param {Number} emitPosY The emitter's y position\n     * @param {int} i The particle number in the current wave. Not used for this function.\n     */\n    Emitter.prototype._spawnCircle = function (p, emitPosX, emitPosY) {\n        //set the initial rotation/direction of the particle based on starting\n        //particle angle and rotation of emitter\n        if (this.minStartRotation == this.maxStartRotation)\n            p.rotation = this.minStartRotation + this.rotation;\n        else\n            p.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) +\n                this.minStartRotation + this.rotation;\n        //place the particle at a random radius in the circle\n        helperPoint.x = Math.random() * this.spawnCircle.radius;\n        helperPoint.y = 0;\n        //rotate the point to a random angle in the circle\n        ParticleUtils_1.default.rotatePoint(Math.random() * 360, helperPoint);\n        //offset by the circle's center\n        helperPoint.x += this.spawnCircle.x;\n        helperPoint.y += this.spawnCircle.y;\n        //rotate the point by the emitter's rotation\n        if (this.rotation !== 0)\n            ParticleUtils_1.default.rotatePoint(this.rotation, helperPoint);\n        //set the position, offset by the emitter's position\n        p.position.x = emitPosX + helperPoint.x;\n        p.position.y = emitPosY + helperPoint.y;\n    };\n    /**\n     * Positions a particle for a ring type emitter.\n     * @method PIXI.particles.Emitter#_spawnRing\n     * @private\n     * @param {Particle} p The particle to position and rotate.\n     * @param {Number} emitPosX The emitter's x position\n     * @param {Number} emitPosY The emitter's y position\n     * @param {int} i The particle number in the current wave. Not used for this function.\n     */\n    Emitter.prototype._spawnRing = function (p, emitPosX, emitPosY) {\n        var spawnCircle = this.spawnCircle;\n        //set the initial rotation/direction of the particle based on starting\n        //particle angle and rotation of emitter\n        if (this.minStartRotation == this.maxStartRotation)\n            p.rotation = this.minStartRotation + this.rotation;\n        else\n            p.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) +\n                this.minStartRotation + this.rotation;\n        //place the particle at a random radius in the ring\n        if (spawnCircle.minRadius !== spawnCircle.radius) {\n            helperPoint.x = Math.random() * (spawnCircle.radius - spawnCircle.minRadius) +\n                spawnCircle.minRadius;\n        }\n        else\n            helperPoint.x = spawnCircle.radius;\n        helperPoint.y = 0;\n        //rotate the point to a random angle in the circle\n        var angle = Math.random() * 360;\n        p.rotation += angle;\n        ParticleUtils_1.default.rotatePoint(angle, helperPoint);\n        //offset by the circle's center\n        helperPoint.x += this.spawnCircle.x;\n        helperPoint.y += this.spawnCircle.y;\n        //rotate the point by the emitter's rotation\n        if (this.rotation !== 0)\n            ParticleUtils_1.default.rotatePoint(this.rotation, helperPoint);\n        //set the position, offset by the emitter's position\n        p.position.x = emitPosX + helperPoint.x;\n        p.position.y = emitPosY + helperPoint.y;\n    };\n    /**\n     * Positions a particle for a spline type emitter.\n     * @method PIXI.particles.Emitter#_spawnSpline\n     * @private\n     * @param {Particle} p The particle to position and rotate.\n     * @param {Number} emitPosX The emitter's x position\n     * @param {Number} emitPosY The emitter's y position\n     * @param {int} i The particle number in the current wave. Not used for this function.\n     */\n    Emitter.prototype._spawnSpline = function (p, emitPosX, emitPosY) {\n        var spawnSpline = this.spawnSpline;\n        //set the initial rotation/direction of the particle based on starting\n        //particle angle and rotation of emitter\n        if (this.minStartRotation == this.maxStartRotation)\n            p.rotation = this.minStartRotation + this.rotation;\n        else\n            p.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) +\n                this.minStartRotation + this.rotation;\n        //place the particle at a random point on the spline\n        var index = spawnSpline.getIndex(Math.random());\n        helperPoint.x = spawnSpline.points[index].x;\n        helperPoint.y = spawnSpline.points[index].y;\n        //rotate the particle to point out of the spline\n        var normal = spawnSpline.getNormals(index).away;\n        p.rotation += PIXI.RAD_TO_DEG * Math.atan2(normal.y, normal.x);\n        //rotate the point by the emitter's rotation\n        if (this.rotation !== 0) {\n            ParticleUtils_1.default.rotatePoint(this.rotation, helperPoint);\n        }\n        //set the position, offset by the emitter's position\n        p.position.x = emitPosX + helperPoint.x;\n        p.position.y = emitPosY + helperPoint.y;\n    };\n    /**\n     * Positions a particle for a burst type emitter.\n     * @method PIXI.particles.Emitter#_spawnBurst\n     * @private\n     * @param {Particle} p The particle to position and rotate.\n     * @param {Number} emitPosX The emitter's x position\n     * @param {Number} emitPosY The emitter's y position\n     * @param {int} i The particle number in the current wave.\n     */\n    Emitter.prototype._spawnBurst = function (p, emitPosX, emitPosY, i) {\n        //set the initial rotation/direction of the particle based on spawn\n        //angle and rotation of emitter\n        if (this.particleSpacing === 0)\n            p.rotation = Math.random() * 360;\n        else\n            p.rotation = this.angleStart + (this.particleSpacing * i) + this.rotation;\n        //drop the particle at the emitter's position\n        p.position.x = emitPosX;\n        p.position.y = emitPosY;\n    };\n    /**\n     * Kills all active particles immediately.\n     * @method PIXI.particles.Emitter#cleanup\n     */\n    Emitter.prototype.cleanup = function () {\n        var particle, next;\n        for (particle = this._activeParticlesFirst; particle; particle = next) {\n            next = particle.next;\n            this.recycle(particle);\n            if (particle.parent)\n                particle.parent.removeChild(particle);\n        }\n        this._activeParticlesFirst = this._activeParticlesLast = null;\n        this.particleCount = 0;\n    };\n    /**\n     * Destroys the emitter and all of its particles.\n     * @method PIXI.particles.Emitter#destroy\n     */\n    Emitter.prototype.destroy = function () {\n        //make sure we aren't still listening to any tickers\n        this.autoUpdate = false;\n        //puts all active particles in the pool, and removes them from the particle parent\n        this.cleanup();\n        //wipe the pool clean\n        var next;\n        for (var particle = this._poolFirst; particle; particle = next) {\n            //store next value so we don't lose it in our destroy call\n            next = particle.next;\n            particle.destroy();\n        }\n        this._poolFirst = this._parent = this.particleImages = this.spawnPos = this.ownerPos =\n            this.startColor = this.startScale = this.startAlpha = this.startSpeed =\n                this.customEase = this._completeCallback = null;\n    };\n    return Emitter;\n}());\nexports.default = Emitter;\n","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ParticleUtils_1 = require(\"./ParticleUtils\");\nvar PropertyList_1 = require(\"./PropertyList\");\nvar Sprite = PIXI.Sprite;\n/**\n * An individual particle image. You shouldn't have to deal with these.\n * @memberof PIXI.particles\n * @class Particle\n * @extends PIXI.Sprite\n * @constructor\n * @param {PIXI.particles.Emitter} emitter The emitter that controls this particle.\n */\nvar Particle = /** @class */ (function (_super) {\n    __extends(Particle, _super);\n    function Particle(emitter) {\n        var _this = \n        //start off the sprite with a blank texture, since we are going to replace it\n        //later when the particle is initialized.\n        _super.call(this) || this;\n        _this.emitter = emitter;\n        //particles should be centered\n        _this.anchor.x = _this.anchor.y = 0.5;\n        _this.velocity = new PIXI.Point();\n        _this.maxLife = 0;\n        _this.age = 0;\n        _this.ease = null;\n        _this.extraData = null;\n        _this.alphaList = new PropertyList_1.default();\n        _this.speedList = new PropertyList_1.default();\n        _this.speedMultiplier = 1;\n        /**\n         * Acceleration to apply to the particle.\n         * @property {PIXI.Point} accleration\n         */\n        _this.acceleration = new PIXI.Point();\n        /**\n         * The maximum speed allowed for accelerating particles. Negative values, values of 0 or NaN\n         * will disable the maximum speed.\n         * @property {Number} maxSpeed\n         * @default NaN\n         */\n        _this.maxSpeed = NaN;\n        /**\n         * The scale of the particle throughout its life.\n         * @property {PIXI.particles.PropertyList} scaleList\n         */\n        _this.scaleList = new PropertyList_1.default();\n        /**\n         * A multiplier from 0-1 applied to the scale of the particle at all times.\n         * @property {number} scaleMultiplier\n         */\n        _this.scaleMultiplier = 1;\n        /**\n         * The tint of the particle throughout its life.\n         * @property {PIXI.particles.PropertyList} colorList\n         */\n        _this.colorList = new PropertyList_1.default(true);\n        /**\n         * If alpha should be interpolated at all.\n         * @property {Boolean} _doAlpha\n         * @private\n         */\n        _this._doAlpha = false;\n        /**\n         * If scale should be interpolated at all.\n         * @property {Boolean} _doScale\n         * @private\n         */\n        _this._doScale = false;\n        /**\n         * If speed should be interpolated at all.\n         * @property {Boolean} _doSpeed\n         * @private\n         */\n        _this._doSpeed = false;\n        /**\n         * If acceleration should be handled at all. _doSpeed is mutually exclusive with this,\n         * and _doSpeed gets priority.\n         * @property {Boolean} _doAcceleration\n         * @private\n         */\n        _this._doAcceleration = false;\n        /**\n         * If color should be interpolated at all.\n         * @property {Boolean} _doColor\n         * @private\n         */\n        _this._doColor = false;\n        /**\n         * If normal movement should be handled. Subclasses wishing to override movement\n         * can set this to false in init().\n         * @property {Boolean} _doNormalMovement\n         * @private\n         */\n        _this._doNormalMovement = false;\n        /**\n         * One divided by the max life of the particle, saved for slightly faster math.\n         * @property {Number} _oneOverLife\n         * @private\n         */\n        _this._oneOverLife = 0;\n        /**\n         * Reference to the next particle in the list.\n         * @property {Particle} next\n         * @private\n         */\n        _this.next = null;\n        /**\n         * Reference to the previous particle in the list.\n         * @property {Particle} prev\n         * @private\n         */\n        _this.prev = null;\n        //save often used functions on the instance instead of the prototype for better speed\n        _this.init = _this.init;\n        _this.Particle_init = Particle.prototype.init;\n        _this.update = _this.update;\n        _this.Particle_update = Particle.prototype.update;\n        _this.Sprite_destroy = _super.prototype.destroy;\n        _this.Particle_destroy = Particle.prototype.destroy;\n        _this.applyArt = _this.applyArt;\n        _this.kill = _this.kill;\n        return _this;\n    }\n    /**\n     * Initializes the particle for use, based on the properties that have to\n     * have been set already on the particle.\n     * @method PIXI.particles.Particle#init\n     */\n    Particle.prototype.init = function () {\n        //reset the age\n        this.age = 0;\n        //set up the velocity based on the start speed and rotation\n        this.velocity.x = this.speedList.current.value * this.speedMultiplier;\n        this.velocity.y = 0;\n        ParticleUtils_1.default.rotatePoint(this.rotation, this.velocity);\n        if (this.noRotation) {\n            this.rotation = 0;\n        }\n        else {\n            //convert rotation to Radians from Degrees\n            this.rotation *= ParticleUtils_1.default.DEG_TO_RADS;\n        }\n        //convert rotation speed to Radians from Degrees\n        this.rotationSpeed *= ParticleUtils_1.default.DEG_TO_RADS;\n        //set alpha to inital alpha\n        this.alpha = this.alphaList.current.value;\n        //set scale to initial scale\n        this.scale.x = this.scale.y = this.scaleList.current.value;\n        //figure out what we need to interpolate\n        this._doAlpha = !!this.alphaList.current.next;\n        this._doSpeed = !!this.speedList.current.next;\n        this._doScale = !!this.scaleList.current.next;\n        this._doColor = !!this.colorList.current.next;\n        this._doAcceleration = this.acceleration.x !== 0 || this.acceleration.y !== 0;\n        //_doNormalMovement can be cancelled by subclasses\n        this._doNormalMovement = this._doSpeed || this.speedList.current.value !== 0 || this._doAcceleration;\n        //save our lerp helper\n        this._oneOverLife = 1 / this.maxLife;\n        //set the inital color\n        var color = this.colorList.current.value;\n        this.tint = ParticleUtils_1.default.combineRGBComponents(color.r, color.g, color.b);\n        //ensure visibility\n        this.visible = true;\n    };\n    /**\n     * Sets the texture for the particle. This can be overridden to allow\n     * for an animated particle.\n     * @method PIXI.particles.Particle#applyArt\n     * @param {PIXI.Texture} art The texture to set.\n     */\n    Particle.prototype.applyArt = function (art) {\n        this.texture = art || PIXI.Texture.EMPTY;\n    };\n    /**\n     * Updates the particle.\n     * @method PIXI.particles.Particle#update\n     * @param {Number} delta Time elapsed since the previous frame, in __seconds__.\n     * @return {Number} The standard interpolation multiplier (0-1) used for all relevant particle\n     *                   properties. A value of -1 means the particle died of old age instead.\n     */\n    Particle.prototype.update = function (delta) {\n        //increase age\n        this.age += delta;\n        //recycle particle if it is too old\n        if (this.age >= this.maxLife || this.age < 0) {\n            this.kill();\n            return -1;\n        }\n        //determine our interpolation value\n        var lerp = this.age * this._oneOverLife; //lifetime / maxLife;\n        if (this.ease) {\n            if (this.ease.length == 4) {\n                //the t, b, c, d parameters that some tween libraries use\n                //(time, initial value, end value, duration)\n                lerp = this.ease(lerp, 0, 1, 1);\n            }\n            else {\n                //the simplified version that we like that takes\n                //one parameter, time from 0-1. TweenJS eases provide this usage.\n                lerp = this.ease(lerp);\n            }\n        }\n        //interpolate alpha\n        if (this._doAlpha)\n            this.alpha = this.alphaList.interpolate(lerp);\n        //interpolate scale\n        if (this._doScale) {\n            var scale = this.scaleList.interpolate(lerp) * this.scaleMultiplier;\n            this.scale.x = this.scale.y = scale;\n        }\n        //handle movement\n        if (this._doNormalMovement) {\n            //interpolate speed\n            if (this._doSpeed) {\n                var speed = this.speedList.interpolate(lerp) * this.speedMultiplier;\n                ParticleUtils_1.default.normalize(this.velocity);\n                ParticleUtils_1.default.scaleBy(this.velocity, speed);\n            }\n            else if (this._doAcceleration) {\n                this.velocity.x += this.acceleration.x * delta;\n                this.velocity.y += this.acceleration.y * delta;\n                if (this.maxSpeed) {\n                    var currentSpeed = ParticleUtils_1.default.length(this.velocity);\n                    //if we are going faster than we should, clamp at the max speed\n                    //DO NOT recalculate vector length\n                    if (currentSpeed > this.maxSpeed) {\n                        ParticleUtils_1.default.scaleBy(this.velocity, this.maxSpeed / currentSpeed);\n                    }\n                }\n            }\n            //adjust position based on velocity\n            this.position.x += this.velocity.x * delta;\n            this.position.y += this.velocity.y * delta;\n        }\n        //interpolate color\n        if (this._doColor) {\n            this.tint = this.colorList.interpolate(lerp);\n        }\n        //update rotation\n        if (this.rotationSpeed !== 0) {\n            this.rotation += this.rotationSpeed * delta;\n        }\n        else if (this.acceleration && !this.noRotation) {\n            this.rotation = Math.atan2(this.velocity.y, this.velocity.x); // + Math.PI / 2;\n        }\n        return lerp;\n    };\n    /**\n     * Kills the particle, removing it from the display list\n     * and telling the emitter to recycle it.\n     * @method PIXI.particles.Particle#kill\n     */\n    Particle.prototype.kill = function () {\n        this.emitter.recycle(this);\n    };\n    /**\n     * Destroys the particle, removing references and preventing future use.\n     * @method PIXI.particles.Particle#destroy\n     */\n    Particle.prototype.destroy = function () {\n        if (this.parent)\n            this.parent.removeChild(this);\n        this.Sprite_destroy();\n        this.emitter = this.velocity = this.colorList = this.scaleList = this.alphaList =\n            this.speedList = this.ease = this.next = this.prev = null;\n    };\n    /**\n     * Checks over the art that was passed to the Emitter's init() function, to do any special\n     * modifications to prepare it ahead of time.\n     * @method PIXI.particles.Particle.parseArt\n     * @static\n     * @param  {Array} art The array of art data. For Particle, it should be an array of Textures.\n     *                     Any strings in the array will be converted to Textures via\n     *                     Texture.fromImage().\n     * @return {Array} The art, after any needed modifications.\n     */\n    Particle.parseArt = function (art) {\n        //convert any strings to Textures.\n        var i;\n        for (i = art.length; i >= 0; --i) {\n            if (typeof art[i] == \"string\")\n                art[i] = PIXI.Texture.fromImage(art[i]);\n        }\n        //particles from different base textures will be slower in WebGL than if they\n        //were from one spritesheet\n        if (ParticleUtils_1.default.verbose) {\n            for (i = art.length - 1; i > 0; --i) {\n                if (art[i].baseTexture != art[i - 1].baseTexture) {\n                    if (window.console)\n                        console.warn(\"PixiParticles: using particle textures from different images may hinder performance in WebGL\");\n                    break;\n                }\n            }\n        }\n        return art;\n    };\n    /**\n     * Parses extra emitter data to ensure it is set up for this particle class.\n     * Particle does nothing to the extra data.\n     * @method PIXI.particles.Particle.parseData\n     * @static\n     * @param  {Object} extraData The extra data from the particle config.\n     * @return {Object} The parsed extra data.\n     */\n    Particle.parseData = function (extraData) {\n        return extraData;\n    };\n    return Particle;\n}(Sprite));\nexports.default = Particle;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BLEND_MODES = PIXI.BLEND_MODES;\nvar PropertyNode_1 = require(\"./PropertyNode\");\n/**\n * Contains helper functions for particles and emitters to use.\n * @memberof PIXI.particles\n * @class ParticleUtils\n * @static\n */\nvar ParticleUtils = {\n    /**\n     * If errors and warnings should be logged within the library.\n     * @name PIXI.particles.ParticleUtils.verbose\n     * @default false\n     * @static\n     */\n    verbose: false,\n    DEG_TO_RADS: Math.PI / 180,\n    /**\n     * Rotates a point by a given angle.\n     * @method PIXI.particles.ParticleUtils.rotatePoint\n     * @param {Number} angle The angle to rotate by in degrees\n     * @param {PIXI.Point} p The point to rotate around 0,0.\n     * @static\n     */\n    rotatePoint: function (angle, p) {\n        if (!angle)\n            return;\n        angle *= ParticleUtils.DEG_TO_RADS;\n        var s = Math.sin(angle);\n        var c = Math.cos(angle);\n        var xnew = p.x * c - p.y * s;\n        var ynew = p.x * s + p.y * c;\n        p.x = xnew;\n        p.y = ynew;\n    },\n    /**\n     * Combines separate color components (0-255) into a single uint color.\n     * @method PIXI.particles.ParticleUtils.combineRGBComponents\n     * @param {uint} r The red value of the color\n     * @param {uint} g The green value of the color\n     * @param {uint} b The blue value of the color\n     * @return {uint} The color in the form of 0xRRGGBB\n     * @static\n     */\n    combineRGBComponents: function (r, g, b /*, a*/) {\n        return /*a << 24 |*/ r << 16 | g << 8 | b;\n    },\n    /**\n     * Reduces the point to a length of 1.\n     * @method PIXI.particles.ParticleUtils.normalize\n     * @static\n     * @param {PIXI.Point} point The point to normalize\n     */\n    normalize: function (point) {\n        var oneOverLen = 1 / ParticleUtils.length(point);\n        point.x *= oneOverLen;\n        point.y *= oneOverLen;\n    },\n    /**\n     * Multiplies the x and y values of this point by a value.\n     * @method PIXI.particles.ParticleUtils.scaleBy\n     * @static\n     * @param {PIXI.Point} point The point to scaleBy\n     * @param {number} value The value to scale by.\n     */\n    scaleBy: function (point, value) {\n        point.x *= value;\n        point.y *= value;\n    },\n    /**\n     * Returns the length (or magnitude) of this point.\n     * @method PIXI.particles.ParticleUtils.length\n     * @static\n     * @param {PIXI.Point} point The point to measure length\n     * @return The length of this point.\n     */\n    length: function (point) {\n        return Math.sqrt(point.x * point.x + point.y * point.y);\n    },\n    /**\n     * Converts a hex string from \"#AARRGGBB\", \"#RRGGBB\", \"0xAARRGGBB\", \"0xRRGGBB\",\n     * \"AARRGGBB\", or \"RRGGBB\" to an object of ints of 0-255, as\n     * {r, g, b, (a)}.\n     * @method PIXI.particles.ParticleUtils.hexToRGB\n     * @param {string} color The input color string.\n     * @param {Object} [output] An object to put the output in. If omitted, a new object is created.\n     * @return The object with r, g, and b properties, possibly with an a property.\n     * @static\n     */\n    hexToRGB: function (color, output) {\n        if (!output)\n            output = {};\n        if (color.charAt(0) == \"#\")\n            color = color.substr(1);\n        else if (color.indexOf(\"0x\") === 0)\n            color = color.substr(2);\n        var alpha;\n        if (color.length == 8) {\n            alpha = color.substr(0, 2);\n            color = color.substr(2);\n        }\n        output.r = parseInt(color.substr(0, 2), 16); //Red\n        output.g = parseInt(color.substr(2, 2), 16); //Green\n        output.b = parseInt(color.substr(4, 2), 16); //Blue\n        if (alpha)\n            output.a = parseInt(alpha, 16);\n        return output;\n    },\n    /**\n     * Generates a custom ease function, based on the GreenSock custom ease, as demonstrated\n     * by the related tool at http://www.greensock.com/customease/.\n     * @method PIXI.particles.ParticleUtils.generateEase\n     * @param {Array} segments An array of segments, as created by\n     * http://www.greensock.com/customease/.\n     * @return {Function} A function that calculates the percentage of change at\n     *                    a given point in time (0-1 inclusive).\n     * @static\n     */\n    generateEase: function (segments) {\n        var qty = segments.length;\n        var oneOverQty = 1 / qty;\n        /*\n         * Calculates the percentage of change at a given point in time (0-1 inclusive).\n         * @param {Number} time The time of the ease, 0-1 inclusive.\n         * @return {Number} The percentage of the change, 0-1 inclusive (unless your\n         *                  ease goes outside those bounds).\n         */\n        return function (time) {\n            var t, s;\n            var i = (qty * time) | 0; //do a quick floor operation\n            t = (time - (i * oneOverQty)) * qty;\n            s = segments[i] || segments[qty - 1];\n            return (s.s + t * (2 * (1 - t) * (s.cp - s.s) + t * (s.e - s.s)));\n        };\n    },\n    /**\n     * Gets a blend mode, ensuring that it is valid.\n     * @method PIXI.particles.ParticleUtils.getBlendMode\n     * @param {string} name The name of the blend mode to get.\n     * @return {int} The blend mode as specified in the PIXI.BLEND_MODES enumeration.\n     * @static\n     */\n    getBlendMode: function (name) {\n        if (!name)\n            return BLEND_MODES.NORMAL;\n        name = name.toUpperCase();\n        while (name.indexOf(\" \") >= 0)\n            name = name.replace(\" \", \"_\");\n        return BLEND_MODES[name] || BLEND_MODES.NORMAL;\n    },\n    /**\n     * Converts a list of {value, time} objects starting at time 0 and ending at time 1 into an evenly\n     * spaced stepped list of PropertyNodes for color values. This is primarily to handle conversion of\n     * linear gradients to fewer colors, allowing for some optimization for Canvas2d fallbacks.\n     * @method PIXI.particles.ParticleUtils.createSteppedGradient\n     * @param {Array} list The list of data to convert.\n     * @param {number} [numSteps=10] The number of steps to use.\n     * @return {PIXI.particles.PropertyNode} The blend mode as specified in the PIXI.blendModes enumeration.\n     * @static\n     */\n    createSteppedGradient: function (list, numSteps) {\n        if (numSteps === void 0) { numSteps = 10; }\n        if (typeof numSteps !== 'number' || numSteps <= 0)\n            numSteps = 10;\n        var first = new PropertyNode_1.default(list[0].value, list[0].time);\n        first.isStepped = true;\n        var currentNode = first;\n        var current = list[0];\n        var nextIndex = 1;\n        var next = list[nextIndex];\n        for (var i = 1; i < numSteps; ++i) {\n            var lerp = i / numSteps;\n            //ensure we are on the right segment, if multiple\n            while (lerp > next.time) {\n                current = next;\n                next = list[++nextIndex];\n            }\n            //convert the lerp value to the segment range\n            lerp = (lerp - current.time) / (next.time - current.time);\n            var curVal = ParticleUtils.hexToRGB(current.value);\n            var nextVal = ParticleUtils.hexToRGB(next.value);\n            var output = {};\n            output.r = (nextVal.r - curVal.r) * lerp + curVal.r;\n            output.g = (nextVal.g - curVal.g) * lerp + curVal.g;\n            output.b = (nextVal.b - curVal.b) * lerp + curVal.b;\n            currentNode.next = new PropertyNode_1.default(output, i / numSteps);\n            currentNode = currentNode.next;\n        }\n        //we don't need to have a PropertyNode for time of 1, because in a stepped version at that point\n        //the particle has died of old age\n        return first;\n    }\n};\nexports.default = ParticleUtils;\n","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ParticleUtils_1 = require(\"./ParticleUtils\");\nvar Particle_1 = require(\"./Particle\");\n/**\n * A helper point for math things.\n * @private\n */\nvar helperPoint = new PIXI.Point();\n//a hand picked list of Math functions (and a couple properties) that are allowable.\n//they should be used without the preceding \"Math.\"\nvar MATH_FUNCS = [\n    \"pow\",\n    \"sqrt\",\n    \"abs\",\n    \"floor\",\n    \"round\",\n    \"ceil\",\n    \"E\",\n    \"PI\",\n    \"sin\",\n    \"cos\",\n    \"tan\",\n    \"asin\",\n    \"acos\",\n    \"atan\",\n    \"atan2\",\n    \"log\"\n];\n//create an actual regular expression object from the string\nvar WHITELISTER = new RegExp([\n    //Allow the 4 basic operations, parentheses and all numbers/decimals, as well\n    //as 'x', for the variable usage.\n    \"[01234567890\\\\.\\\\*\\\\-\\\\+\\\\/\\\\(\\\\)x ,]\",\n].concat(MATH_FUNCS).join(\"|\"), \"g\");\n/**\n * Parses a string into a function for path following.\n * This involves whitelisting the string for safety, inserting \"Math.\" to math function\n * names, and using `new Function()` to generate a function.\n * @method PIXI.particles.PathParticle~parsePath\n * @private\n * @static\n * @param {String} pathString The string to parse.\n * @return {Function} The path function - takes x, outputs y.\n */\nvar parsePath = function (pathString) {\n    var matches = pathString.match(WHITELISTER);\n    for (var i = matches.length - 1; i >= 0; --i) {\n        if (MATH_FUNCS.indexOf(matches[i]) >= 0)\n            matches[i] = \"Math.\" + matches[i];\n    }\n    pathString = matches.join(\"\");\n    return new Function(\"x\", \"return \" + pathString + \";\");\n};\n/**\n * An particle that follows a path defined by an algebraic expression, e.g. \"sin(x)\" or\n * \"5x + 3\".\n * To use this class, the particle config must have a \"path\" string in the\n * \"extraData\" parameter. This string should have \"x\" in it to represent movement (from the\n * speed settings of the particle). It may have numbers, parentheses, the four basic\n * operations, and the following Math functions or properties (without the preceding \"Math.\"):\n * \"pow\", \"sqrt\", \"abs\", \"floor\", \"round\", \"ceil\", \"E\", \"PI\", \"sin\", \"cos\", \"tan\", \"asin\",\n * \"acos\", \"atan\", \"atan2\", \"log\".\n * The overall movement of the particle and the expression value become x and y positions for\n * the particle, respectively. The final position is rotated by the spawn rotation/angle of\n * the particle.\n *\n * Some example paths:\n *\n * \t\"sin(x/10) * 20\" // A sine wave path.\n * \t\"cos(x/100) * 30\" // Particles curve counterclockwise (for medium speed/low lifetime particles)\n * \t\"pow(x/10, 2) / 2\" // Particles curve clockwise (remember, +y is down).\n *\n * @memberof PIXI.particles\n * @class PathParticle\n * @extends PIXI.particles.Particle\n * @constructor\n * @param {PIXI.particles.Emitter} emitter The emitter that controls this PathParticle.\n */\nvar PathParticle = /** @class */ (function (_super) {\n    __extends(PathParticle, _super);\n    function PathParticle(emitter) {\n        var _this = _super.call(this, emitter) || this;\n        _this.path = null;\n        _this.initialRotation = 0;\n        _this.initialPosition = new PIXI.Point();\n        _this.movement = 0;\n        return _this;\n    }\n    /**\n     * Initializes the particle for use, based on the properties that have to\n     * have been set already on the particle.\n     * @method PIXI.particles.PathParticle#init\n     */\n    PathParticle.prototype.init = function () {\n        //get initial rotation before it is converted to radians\n        this.initialRotation = this.rotation;\n        //standard init\n        this.Particle_init();\n        //set the path for the particle\n        this.path = this.extraData.path;\n        //cancel the normal movement behavior\n        this._doNormalMovement = !this.path;\n        //reset movement\n        this.movement = 0;\n        //grab position\n        this.initialPosition.x = this.position.x;\n        this.initialPosition.y = this.position.y;\n    };\n    /**\n     * Updates the particle.\n     * @method PIXI.particles.PathParticle#update\n     * @param {Number} delta Time elapsed since the previous frame, in __seconds__.\n     */\n    PathParticle.prototype.update = function (delta) {\n        var lerp = this.Particle_update(delta);\n        //if the particle died during the update, then don't bother\n        if (lerp >= 0 && this.path) {\n            //increase linear movement based on speed\n            var speed = this.speedList.interpolate(lerp) * this.speedMultiplier;\n            this.movement += speed * delta;\n            //set up the helper point for rotation\n            helperPoint.x = this.movement;\n            helperPoint.y = this.path(this.movement);\n            ParticleUtils_1.default.rotatePoint(this.initialRotation, helperPoint);\n            this.position.x = this.initialPosition.x + helperPoint.x;\n            this.position.y = this.initialPosition.y + helperPoint.y;\n        }\n        return lerp;\n    };\n    /**\n     * Destroys the particle, removing references and preventing future use.\n     * @method PIXI.particles.PathParticle#destroy\n     */\n    PathParticle.prototype.destroy = function () {\n        this.Particle_destroy();\n        this.path = this.initialPosition = null;\n    };\n    /**\n     * Checks over the art that was passed to the Emitter's init() function, to do any special\n     * modifications to prepare it ahead of time. This just runs Particle.parseArt().\n     * @method PIXI.particles.PathParticle.parseArt\n     * @static\n     * @param  {Array} art The array of art data. For Particle, it should be an array of Textures.\n     *                     Any strings in the array will be converted to Textures via\n     *                     Texture.fromImage().\n     * @return {Array} The art, after any needed modifications.\n     */\n    PathParticle.parseArt = function (art) {\n        return Particle_1.default.parseArt(art);\n    };\n    /**\n     * Parses extra emitter data to ensure it is set up for this particle class.\n     * PathParticle checks for the existence of path data, and parses the path data for use\n     * by particle instances.\n     * @method PIXI.particles.PathParticle.parseData\n     * @static\n     * @param  {Object} extraData The extra data from the particle config.\n     * @return {Object} The parsed extra data.\n     */\n    PathParticle.parseData = function (extraData) {\n        var output = {};\n        if (extraData && extraData.path) {\n            try {\n                output.path = parsePath(extraData.path);\n            }\n            catch (e) {\n                if (ParticleUtils_1.default.verbose)\n                    console.error(\"PathParticle: error in parsing path expression\");\n                output.path = null;\n            }\n        }\n        else {\n            if (ParticleUtils_1.default.verbose)\n                console.error(\"PathParticle requires a path string in extraData!\");\n            output.path = null;\n        }\n        return output;\n    };\n    return PathParticle;\n}(Particle_1.default));\nexports.default = PathParticle;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ParticleUtils_1 = require(\"./ParticleUtils\");\n/**\n * Singly linked list container for keeping track of interpolated properties for particles.\n * Each Particle will have one of these for each interpolated property.\n * @memberof PIXI.particles\n * @class PropertyList\n * @constructor\n * @param {boolean} isColor If this list handles color values\n */\nvar PropertyList = /** @class */ (function () {\n    function PropertyList(isColor) {\n        if (isColor === void 0) { isColor = false; }\n        this.current = null;\n        this.next = null;\n        this.isColor = !!isColor;\n        this.interpolate = null;\n        this.ease = null;\n    }\n    /**\n     * Resets the list for use.\n     * @method interpolate\n     * @param {PIXI.particles.PropertyNode} first The first node in the list.\n     * @param {boolean} [isStepped=false] If the values should be stepped instead of interpolated linearly.\n     */\n    PropertyList.prototype.reset = function (first) {\n        this.current = first;\n        this.next = first.next;\n        var isSimple = this.next && this.next.time >= 1;\n        if (isSimple) {\n            this.interpolate = this.isColor ? intColorSimple : intValueSimple;\n        }\n        else if (first.isStepped) {\n            this.interpolate = this.isColor ? intColorStepped : intValueStepped;\n        }\n        else {\n            this.interpolate = this.isColor ? intColorComplex : intValueComplex;\n        }\n        this.ease = this.current.ease;\n    };\n    return PropertyList;\n}());\nexports.default = PropertyList;\nfunction intValueSimple(lerp) {\n    if (this.ease)\n        lerp = this.ease(lerp);\n    return (this.next.value - this.current.value) * lerp + this.current.value;\n}\nfunction intColorSimple(lerp) {\n    if (this.ease)\n        lerp = this.ease(lerp);\n    var curVal = this.current.value, nextVal = this.next.value;\n    var r = (nextVal.r - curVal.r) * lerp + curVal.r;\n    var g = (nextVal.g - curVal.g) * lerp + curVal.g;\n    var b = (nextVal.b - curVal.b) * lerp + curVal.b;\n    return ParticleUtils_1.default.combineRGBComponents(r, g, b);\n}\nfunction intValueComplex(lerp) {\n    if (this.ease)\n        lerp = this.ease(lerp);\n    //make sure we are on the right segment\n    while (lerp > this.next.time) {\n        this.current = this.next;\n        this.next = this.next.next;\n    }\n    //convert the lerp value to the segment range\n    lerp = (lerp - this.current.time) / (this.next.time - this.current.time);\n    return (this.next.value - this.current.value) * lerp + this.current.value;\n}\nfunction intColorComplex(lerp) {\n    if (this.ease)\n        lerp = this.ease(lerp);\n    //make sure we are on the right segment\n    while (lerp > this.next.time) {\n        this.current = this.next;\n        this.next = this.next.next;\n    }\n    //convert the lerp value to the segment range\n    lerp = (lerp - this.current.time) / (this.next.time - this.current.time);\n    var curVal = this.current.value, nextVal = this.next.value;\n    var r = (nextVal.r - curVal.r) * lerp + curVal.r;\n    var g = (nextVal.g - curVal.g) * lerp + curVal.g;\n    var b = (nextVal.b - curVal.b) * lerp + curVal.b;\n    return ParticleUtils_1.default.combineRGBComponents(r, g, b);\n}\nfunction intValueStepped(lerp) {\n    if (this.ease)\n        lerp = this.ease(lerp);\n    //make sure we are on the right segment\n    while (this.next && lerp > this.next.time) {\n        this.current = this.next;\n        this.next = this.next.next;\n    }\n    return this.current.value;\n}\nfunction intColorStepped(lerp) {\n    if (this.ease)\n        lerp = this.ease(lerp);\n    //make sure we are on the right segment\n    while (this.next && lerp > this.next.time) {\n        this.current = this.next;\n        this.next = this.next.next;\n    }\n    var curVal = this.current.value;\n    return ParticleUtils_1.default.combineRGBComponents(curVal.r, curVal.g, curVal.b);\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ParticleUtils_1 = require(\"./ParticleUtils\");\n/**\n * A single node in a PropertyList.\n * @memberof PIXI.particles\n * @class PropertyNode\n * @constructor\n * @param {number|string} value The value for this node\n * @param {number} time The time for this node, between 0-1\n * @param {Function|Array} [ease] Custom ease for this list. Only relevant for the first node.\n */\nvar PropertyNode = /** @class */ (function () {\n    function PropertyNode(value, time, ease) {\n        this.value = typeof value == \"string\" ? ParticleUtils_1.default.hexToRGB(value) : value;\n        this.time = time;\n        this.next = null;\n        this.isStepped = false;\n        if (ease) {\n            this.ease = typeof ease == \"function\" ? ease : ParticleUtils_1.default.generateEase(ease);\n        }\n        else {\n            this.ease = null;\n        }\n    }\n    /**\n     * Creates a list of property values from a data object {list, isStepped} with a list of objects in\n     * the form {value, time}. Alternatively, the data object can be in the deprecated form of\n     * {start, end}.\n     * @method PIXI.particles.PropertyNode.createListFromArray\n     * @static\n     * @param  {Object} data The data for the list.\n     * @param  {Array} data.list The array of value and time objects.\n     * @param  {boolean} [data.isStepped] If the list is stepped rather than interpolated.\n     * @param  {Function|Array} [data.ease] Custom ease for this list.\n     * @return {PIXI.particles.PropertyNode} The first node in the list\n     */\n    PropertyNode.createList = function (data) {\n        if (Array.isArray(data.list)) {\n            var array = data.list;\n            var node = void 0, first = void 0;\n            first = node = new PropertyNode(array[0].value, array[0].time, data.ease);\n            //only set up subsequent nodes if there are a bunch or the 2nd one is different from the first\n            if (array.length > 2 || (array.length === 2 && array[1].value !== array[0].value)) {\n                for (var i = 1; i < array.length; ++i) {\n                    node.next = new PropertyNode(array[i].value, array[i].time);\n                    node = node.next;\n                }\n            }\n            first.isStepped = !!data.isStepped;\n            return first;\n        }\n        else {\n            //Handle deprecated version here\n            var start = new PropertyNode(data.start, 0);\n            //only set up a next value if it is different from the starting value\n            if (data.end !== data.start)\n                start.next = new PropertyNode(data.end, 1);\n            return start;\n        }\n    };\n    return PropertyNode;\n}());\nexports.default = PropertyNode;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ParticleUtils_js_1 = require(\"./ParticleUtils.js\");\nexports.ParticleUtils = ParticleUtils_js_1.default;\nvar Particle_js_1 = require(\"./Particle.js\");\nexports.Particle = Particle_js_1.default;\nvar Emitter_js_1 = require(\"./Emitter.js\");\nexports.Emitter = Emitter_js_1.default;\nvar PathParticle_js_1 = require(\"./PathParticle.js\");\nexports.PathParticle = PathParticle_js_1.default;\nvar AnimatedParticle_js_1 = require(\"./AnimatedParticle.js\");\nexports.AnimatedParticle = AnimatedParticle_js_1.default;\nvar CatmullRom_js_1 = require(\"./CatmullRom.js\");\nexports.CatmullRom = CatmullRom_js_1.default;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// If we're in the browser make sure PIXI is available\nif (typeof PIXI === 'undefined') {\n    throw \"pixi-particles requires pixi.js to be loaded first\";\n}\n//ensure that the particles namespace exist - PIXI 4 creates it itself, PIXI 3 does not\nif (!PIXI.particles) {\n    PIXI.particles = {};\n}\n// get the library itself\nvar particles = require(\"./particles\");\n// insert the library into the particles namespace on PIXI\nfor (var prop in particles) {\n    PIXI.particles[prop] = particles[prop];\n}\nif (typeof module !== \"undefined\" && module.exports) {\n    module.exports = particles;\n}\n"],"sourceRoot":"."}